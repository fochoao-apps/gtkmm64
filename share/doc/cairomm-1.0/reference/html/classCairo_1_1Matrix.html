<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
        <title>cairomm: Cairo::Matrix Class Reference</title>
        <link href="cairomm.css" rel="stylesheet" type="text/css">
    </head>
<body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceCairo.html">Cairo</a>::<a class="el" href="classCairo_1_1Matrix.html">Matrix</a>
  </div>
</div>
<div class="contents">
<h1>Cairo::Matrix Class Reference</h1><!-- doxytag: class="Cairo::Matrix" --><!-- doxytag: inherits="cairo_matrix_t" -->A Transformation matrix.  
<a href="#_details">More...</a>
<p>
Inherits <a class="el" href="classcairo__matrix__t.html">cairo_matrix_t</a>.
<p>

<p>
<a href="classCairo_1_1Matrix-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#69297a4b8adc2bdecece4c372edc1e63">Matrix</a> ()</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized matrix.  <a href="#69297a4b8adc2bdecece4c372edc1e63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#90a6fe36d7744bfd607c2b37435ca8e6">Matrix</a> (double xx, double yx, double xy, double yy, double x0, double y0)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix Sets to be the affine transformation given by xx, yx, xy, yy, x0, y0.  <a href="#90a6fe36d7744bfd607c2b37435ca8e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#ec65d01b5251144dc20708f0b05940f6">translate</a> (double tx, double ty)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a translation by tx, ty to the transformation in matrix.  <a href="#ec65d01b5251144dc20708f0b05940f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#697c488fb323f4a6edda4edd0533c95c">scale</a> (double sx, double sy)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies scaling by sx, sy to the transformation in matrix.  <a href="#697c488fb323f4a6edda4edd0533c95c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#98b3feae5ff15937c764ebec846efb33">rotate</a> (double radians)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies rotation by radians to the transformation in matrix.  <a href="#98b3feae5ff15937c764ebec846efb33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#3ad532fa3b90ac4019d6a535ffde0cd4">invert</a> ()</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes matrix to be the inverse of it's original value.  <a href="#3ad532fa3b90ac4019d6a535ffde0cd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#748df1dafe6a35422fa51b31f6932587">multiply</a> (<a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&amp; a, <a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&amp; b)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the affine transformations in a and b together and stores the result in this matrix.  <a href="#748df1dafe6a35422fa51b31f6932587"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#7966181b002249878a895bb3911f39e8">transform_distance</a> (double&amp; dx, double&amp; dy) const </td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the distance vector (dx,dy) by matrix.  <a href="#7966181b002249878a895bb3911f39e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#f0b0ac8dd645036fdd4a3ee54cdcaca6">transform_point</a> (double&amp; x, double&amp; y) const </td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the point (x, y) by this matrix.  <a href="#f0b0ac8dd645036fdd4a3ee54cdcaca6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#293cbaf13eb86244648cb558b2cf7dd3">identity_matrix</a> ()</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> initialized to the identity matrix.  <a href="#293cbaf13eb86244648cb558b2cf7dd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#e638d4c68c7f26f9760335eb42680cea">translation_matrix</a> (double tx, double ty)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> initialized to a transformation that translates by tx and ty in the X and Y dimensions, respectively.  <a href="#e638d4c68c7f26f9760335eb42680cea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#c217befdf043bdb5f1c29632e60cbdef">scaling_matrix</a> (double sx, double sy)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> initialized to a transformation that scales by sx and sy in the X and Y dimensions, respectively.  <a href="#c217befdf043bdb5f1c29632e60cbdef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#324cadc45a2fe7424cb0d0d6b73ccbe8">rotation_matrix</a> (double radians)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> initialized to a transformation that rotates by radians.  <a href="#324cadc45a2fe7424cb0d0d6b73ccbe8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Matrix.html#b0bbb2ec9c1451f42f0270652df8cada">operator*</a> (const <a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&amp; a, const <a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&amp; b)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the affine transformations in a and b together and returns the result.  <a href="#b0bbb2ec9c1451f42f0270652df8cada"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A Transformation matrix. 
<p>
<a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Cairo::Matrix</a> is used throughout cairomm to convert between different coordinate spaces. A <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> holds an affine transformation, such as a scale, rotation, shear, or a combination of these. The transformation of a point (x,y) is given by:<p>
<div class="fragment"><pre class="fragment"> x_new = xx * x + xy * y + x0;
 y_new = yx * x + yy * y + y0;
</pre></div><p>
The current transformation matrix of a <a class="el" href="classCairo_1_1Context.html" title="Context is the main class used to draw in cairomm.">Context</a>, represented as a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a>, defines the transformation from user-space coordinates to device-space coordinates. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classCairo_1_1Context.html#03b21f4a3a44e28086c3a25075fdcea1" title="Stores the current transformation matrix (CTM) into matrix.">Context::get_matrix()</a> <p>
<a class="el" href="classCairo_1_1Context.html#c2eafbac5591e569d22495f7920d60d2" title="Modifies the current transformation matrix (CTM) by setting it equal to matrix.">Context::set_matrix()</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="69297a4b8adc2bdecece4c372edc1e63"></a><!-- doxytag: member="Cairo::Matrix::Matrix" ref="69297a4b8adc2bdecece4c372edc1e63" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cairo::Matrix::Matrix           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an uninitialized matrix. 
<p>
If you want a matrix initialized to a certain value, either specify the values explicitly with the other constructor or use one of the free functions for initializing matrices with specific scales, rotations, etc.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classCairo_1_1Matrix.html#293cbaf13eb86244648cb558b2cf7dd3" title="Returns a Matrix initialized to the identity matrix.">identity_matrix()</a> <p>
<a class="el" href="classCairo_1_1Matrix.html#324cadc45a2fe7424cb0d0d6b73ccbe8" title="Returns a Matrix initialized to a transformation that rotates by radians.">rotation_matrix()</a> <p>
<a class="el" href="classCairo_1_1Matrix.html#e638d4c68c7f26f9760335eb42680cea" title="Returns a Matrix initialized to a transformation that translates by tx and ty in...">translation_matrix()</a> <p>
<a class="el" href="classCairo_1_1Matrix.html#c217befdf043bdb5f1c29632e60cbdef" title="Returns a Matrix initialized to a transformation that scales by sx and sy in the...">scaling_matrix()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="90a6fe36d7744bfd607c2b37435ca8e6"></a><!-- doxytag: member="Cairo::Matrix::Matrix" ref="90a6fe36d7744bfd607c2b37435ca8e6" args="(double xx, double yx, double xy, double yy, double x0, double y0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cairo::Matrix::Matrix           </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>yx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>y0</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a matrix Sets to be the affine transformation given by xx, yx, xy, yy, x0, y0. 
<p>
The transformation is given by:<p>
<div class="fragment"><pre class="fragment"> x_new = xx * x + xy * y + x0;
 y_new = yx * x + yy * y + y0;
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xx</em>&#160;</td><td>xx component of the affine transformation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yx</em>&#160;</td><td>yx component of the affine transformation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xy</em>&#160;</td><td>xy component of the affine transformation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yy</em>&#160;</td><td>yy component of the affine transformation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x0</em>&#160;</td><td>X translation component of the affine transformation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y0</em>&#160;</td><td>Y translation component of the affine transformation </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3ad532fa3b90ac4019d6a535ffde0cd4"></a><!-- doxytag: member="Cairo::Matrix::invert" ref="3ad532fa3b90ac4019d6a535ffde0cd4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Matrix::invert           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes matrix to be the inverse of it's original value. 
<p>
Not all transformation matrices have inverses; if the matrix collapses points together (it is degenerate), then it has no inverse and this function will throw an exception. 
</div>
</div><p>
<a class="anchor" name="748df1dafe6a35422fa51b31f6932587"></a><!-- doxytag: member="Cairo::Matrix::multiply" ref="748df1dafe6a35422fa51b31f6932587" args="(Matrix &amp;a, Matrix &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Matrix::multiply           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&amp;&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&amp;&#160;</td>
          <td class="paramname"> <em>b</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies the affine transformations in a and b together and stores the result in this matrix. 
<p>
The effect of the resulting transformation is to first apply the transformation in a to the coordinates and then apply the transformation in b to the coordinates.<p>
It is allowable for result to be identical to either a or b.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&#160;</td><td>a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&#160;</td><td>a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a></td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classCairo_1_1Matrix.html#b0bbb2ec9c1451f42f0270652df8cada" title="Multiplies the affine transformations in a and b together and returns the result...">operator*()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="98b3feae5ff15937c764ebec846efb33"></a><!-- doxytag: member="Cairo::Matrix::rotate" ref="98b3feae5ff15937c764ebec846efb33" args="(double radians)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Matrix::rotate           </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>radians</em>          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies rotation by radians to the transformation in matrix. 
<p>
The effect of the new transformation is to first rotate the coordinates by radians, then apply the original transformation to the coordinates.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radians</em>&#160;</td><td>angle of rotation, in radians. The direction of rotation is defined such that positive angles rotate in the direction from the positive X axis toward the positive Y axis. With the default axis orientation of cairo, positive angles rotate in a clockwise direction. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="697c488fb323f4a6edda4edd0533c95c"></a><!-- doxytag: member="Cairo::Matrix::scale" ref="697c488fb323f4a6edda4edd0533c95c" args="(double sx, double sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Matrix::scale           </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>sy</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies scaling by sx, sy to the transformation in matrix. 
<p>
The effect of the new transformation is to first scale the coordinates by sx and sy, then apply the original transformation to the coordinates.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sx</em>&#160;</td><td>scale factor in the X direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sy</em>&#160;</td><td>scale factor in the Y direction </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7966181b002249878a895bb3911f39e8"></a><!-- doxytag: member="Cairo::Matrix::transform_distance" ref="7966181b002249878a895bb3911f39e8" args="(double &amp;dx, double &amp;dy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Matrix::transform_distance           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>dy</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transforms the distance vector (dx,dy) by matrix. 
<p>
This is similar to <a class="el" href="classCairo_1_1Matrix.html#f0b0ac8dd645036fdd4a3ee54cdcaca6" title="Transforms the point (x, y) by this matrix.">transform_point()</a> except that the translation components of the transformation are ignored. The calculation of the returned vector is as follows:<p>
<div class="fragment"><pre class="fragment"> dx2 = dx1 * a + dy1 * c;
 dy2 = dx1 * b + dy1 * d;
</pre></div><p>
Affine transformations are position invariant, so the same vector always transforms to the same vector. If (x1,y1) transforms to (x2,y2) then (x1+dx1,y1+dy1) will transform to (x1+dx2,y1+dy2) for all values of x1 and x2.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&#160;</td><td>X component of a distance vector. An in/out parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&#160;</td><td>Y component of a distance vector. An in/out parameter </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f0b0ac8dd645036fdd4a3ee54cdcaca6"></a><!-- doxytag: member="Cairo::Matrix::transform_point" ref="f0b0ac8dd645036fdd4a3ee54cdcaca6" args="(double &amp;x, double &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Matrix::transform_point           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transforms the point (x, y) by this matrix. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&#160;</td><td>X position. An in/out parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>Y position. An in/out parameter </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec65d01b5251144dc20708f0b05940f6"></a><!-- doxytag: member="Cairo::Matrix::translate" ref="ec65d01b5251144dc20708f0b05940f6" args="(double tx, double ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Matrix::translate           </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>ty</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies a translation by tx, ty to the transformation in matrix. 
<p>
The effect of the new transformation is to first translate the coordinates by tx and ty, then apply the original transformation to the coordinates.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tx</em>&#160;</td><td>amount to translate in the X direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ty</em>&#160;</td><td>amount to translate in the Y direction </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="293cbaf13eb86244648cb558b2cf7dd3"></a><!-- doxytag: member="Cairo::Matrix::identity_matrix" ref="293cbaf13eb86244648cb558b2cf7dd3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a> identity_matrix           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> initialized to the identity matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="b0bbb2ec9c1451f42f0270652df8cada"></a><!-- doxytag: member="Cairo::Matrix::operator*" ref="b0bbb2ec9c1451f42f0270652df8cada" args="(const Matrix &amp;a, const Matrix &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a> operator*           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&amp;&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1Matrix.html">Matrix</a>&amp;&#160;</td>
          <td class="paramname"> <em>b</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies the affine transformations in a and b together and returns the result. 
<p>
The effect of the resulting transformation is to first apply the transformation in a to the coordinates and then apply the transformation in b to the coordinates.<p>
It is allowable for result to be identical to either a or b.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&#160;</td><td>a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&#160;</td><td>a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="324cadc45a2fe7424cb0d0d6b73ccbe8"></a><!-- doxytag: member="Cairo::Matrix::rotation_matrix" ref="324cadc45a2fe7424cb0d0d6b73ccbe8" args="(double radians)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a> rotation_matrix           </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>radians</em>          </td>
          <td>&#160;)&#160;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> initialized to a transformation that rotates by radians. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radians</em>&#160;</td><td>angle of rotation, in radians. The direction of rotation is defined such that positive angles rotate in the direction from the positive X axis toward the positive Y axis. With the default axis orientation of cairo, positive angles rotate in a clockwise direction. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c217befdf043bdb5f1c29632e60cbdef"></a><!-- doxytag: member="Cairo::Matrix::scaling_matrix" ref="c217befdf043bdb5f1c29632e60cbdef" args="(double sx, double sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a> scaling_matrix           </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>sy</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> initialized to a transformation that scales by sx and sy in the X and Y dimensions, respectively. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sx</em>&#160;</td><td>scale factor in the X direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sy</em>&#160;</td><td>scale factor in the Y direction </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e638d4c68c7f26f9760335eb42680cea"></a><!-- doxytag: member="Cairo::Matrix::translation_matrix" ref="e638d4c68c7f26f9760335eb42680cea" args="(double tx, double ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Matrix.html">Matrix</a> translation_matrix           </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>ty</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <a class="el" href="classCairo_1_1Matrix.html" title="A Transformation matrix.">Matrix</a> initialized to a transformation that translates by tx and ty in the X and Y dimensions, respectively. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tx</em>&#160;</td><td>amount to translate in the X direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ty</em>&#160;</td><td>amount to translate in the Y direction </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>cairomm/matrix.h</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 13 11:40:14 2009 for cairomm by&#160;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
