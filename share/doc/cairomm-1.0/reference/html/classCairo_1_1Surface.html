<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
        <title>cairomm: Cairo::Surface Class Reference</title>
        <link href="cairomm.css" rel="stylesheet" type="text/css">
    </head>
<body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceCairo.html">Cairo</a>::<a class="el" href="classCairo_1_1Surface.html">Surface</a>
  </div>
</div>
<div class="contents">
<h1>Cairo::Surface Class Reference</h1><!-- doxytag: class="Cairo::Surface" -->A cairo surface represents an image, either as the destination of a drawing operation or as source when drawing onto another surface.  
<a href="#_details">More...</a>
<p>
Inherited by <a class="el" href="classCairo_1_1GlitzSurface.html">Cairo::GlitzSurface</a>, <a class="el" href="classCairo_1_1ImageSurface.html">Cairo::ImageSurface</a>, <a class="el" href="classCairo_1_1PdfSurface.html">Cairo::PdfSurface</a>, <a class="el" href="classCairo_1_1PsSurface.html">Cairo::PsSurface</a>, <a class="el" href="classCairo_1_1QuartzSurface.html">Cairo::QuartzSurface</a>, <a class="el" href="classCairo_1_1SvgSurface.html">Cairo::SvgSurface</a>, <a class="el" href="classCairo_1_1Win32PrintingSurface.html">Cairo::Win32PrintingSurface</a>, <a class="el" href="classCairo_1_1Win32Surface.html">Cairo::Win32Surface</a>, and <a class="el" href="classCairo_1_1XlibSurface.html">Cairo::XlibSurface</a>.
<p>

<p>
<a href="classCairo_1_1Surface-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef sigc::slot<br class="typebreak">
&lt; ErrorStatus, const unsigned <br class="typebreak">
char*, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#02fb9416d466b762bc5845b0ae204f49">SlotWriteFunc</a></td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For example: <code> ErrorStatus my_write_func(unsigned char* data, unsigned int length); </code>.  <a href="#02fb9416d466b762bc5845b0ae204f49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef sigc::slot<br class="typebreak">
&lt; ErrorStatus, unsigned char <br class="typebreak">
*, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#f66be8453e3fc558ea1282a911bf60e2">SlotReadFunc</a></td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of function which is called when a backend needs to read data from an input stream.  <a href="#f66be8453e3fc558ea1282a911bf60e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef cairo_surface_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#d176eb7343b5902df3c19f9f56e59fb4">cobject</a></td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying C cairo surface type.  <a href="#d176eb7343b5902df3c19f9f56e59fb4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#47b90669a5a85d187cc0d28dc99915c8">Surface</a> (cairo_surface_t*<a class="el" href="classCairo_1_1Surface.html#d176eb7343b5902df3c19f9f56e59fb4">cobject</a>, bool has_reference=false)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a C++ wrapper for the C instance.  <a href="#47b90669a5a85d187cc0d28dc99915c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#64ca52e9e8e9a64358ff85e6ef0d93c1">~Surface</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#7e3dd712e398719315bbd89efe9af0b2">get_font_options</a> (<a class="el" href="classCairo_1_1FontOptions.html">FontOptions</a>&amp; options) const </td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the default font rendering options for the surface.  <a href="#7e3dd712e398719315bbd89efe9af0b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#8d8afee4ddb4935b85698f27099646a0">finish</a> ()</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finishes the surface and drops all references to external resources.  <a href="#8d8afee4ddb4935b85698f27099646a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#8f95678918fb40bae15f8aad2adb6ef2">flush</a> ()</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Do any pending drawing for the surface and also restore any temporary modifications cairo has made to the surface's state.  <a href="#8f95678918fb40bae15f8aad2adb6ef2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#77b1f860cc55f4ad168e100108e0b7bb">mark_dirty</a> ()</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells cairo to consider the data buffer dirty.  <a href="#77b1f860cc55f4ad168e100108e0b7bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#1dbf3a036b7dc7c09fc86996ea1ee61f">mark_dirty</a> (int x, int y, int width, int height)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a rectangular area of the given surface dirty.  <a href="#1dbf3a036b7dc7c09fc86996ea1ee61f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#957e290a548d3cba65aa9e3fd0c86180">set_device_offset</a> (double x_offset, double y_offset)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface.  <a href="#957e290a548d3cba65aa9e3fd0c86180"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#5861783d0f5f3b396f52791a93e668fe">get_device_offset</a> (double&amp; x_offset, double&amp; y_offset) const </td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a previous device offset set by <a class="el" href="classCairo_1_1Surface.html#957e290a548d3cba65aa9e3fd0c86180" title="Sets an offset that is added to the device coordinates determined by the CTM when...">set_device_offset()</a>.  <a href="#5861783d0f5f3b396f52791a93e668fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#c8caca30702fe2bd69ae89929ee784e8">set_fallback_resolution</a> (double x_pixels_per_inch, double y_pixels_per_inch)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fallback resolution of the image in dots per inch.  <a href="#c8caca30702fe2bd69ae89929ee784e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a3a8d5a2b5c91d11f7758d0a67f6093a">get_fallback_resolution</a> (double&amp; x_pixels_per_inch, double&amp; y_pixels_per_inch) const </td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the previous fallback resolution set by <a class="el" href="classCairo_1_1Surface.html#c8caca30702fe2bd69ae89929ee784e8" title="Sets the fallback resolution of the image in dots per inch.">set_fallback_resolution()</a>, or default fallback resolution if never set.  <a href="#a3a8d5a2b5c91d11f7758d0a67f6093a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceCairo.html#f11d962e38a38a2d92fc1473fbe92549">SurfaceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#7ee0760ea1895f5e6c8f6673f83cc072">get_type</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceCairo.html#1f0f5d82599dfeabbeb2396dbfd767d0">Content</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#5fe39669b1d4239f3e4f73a8bf5105a5">get_content</a> () const </td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the content type of surface which indicates whether the surface contains color and/or alpha information.  <a href="#5fe39669b1d4239f3e4f73a8bf5105a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ae22bcaa9becbf3ca703a380f70c2c0a">copy_page</a> ()</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the current page for backends that support multiple pages, but doesn't clear it, so that the contents of the current page will be retained for the next page.  <a href="#ae22bcaa9becbf3ca703a380f70c2c0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#d318acd86c1875854ef4e1e2867052c3">show_page</a> ()</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits and clears the current page for backends that support multiple pages.  <a href="#d318acd86c1875854ef4e1e2867052c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#e4e133bf758c85195db6d3ccfbe1d54a">has_show_text_glyphs</a> () const </td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the surface supports sophisticated <a class="el" href="classCairo_1_1Context.html#45723fd605cc2343ab46cf603d330002">Context::show_text_glyphs()</a> operations.  <a href="#e4e133bf758c85195db6d3ccfbe1d54a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#153405d271814ab4d47b90a1c36d2370">write_to_png</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00218.html">std::string</a>&amp; filename)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the contents of surface to a new file filename as a PNG image.  <a href="#153405d271814ab4d47b90a1c36d2370"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#b3eca5bc13abe27f470fdf08134269bb">write_to_png_stream</a> (const <a class="el" href="classCairo_1_1Surface.html#02fb9416d466b762bc5845b0ae204f49">SlotWriteFunc</a>&amp; write_func)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation...">Surface</a> to the write function.  <a href="#b3eca5bc13abe27f470fdf08134269bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#83763b7906a666b095ce376271455457">write_to_png</a> (cairo_write_func_t write_func, void* closure)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCairo_1_1Surface.html#d176eb7343b5902df3c19f9f56e59fb4">cobject</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#17d8f600aedba416bb640ac841494bde">cobj</a> ()</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides acces to the underlying C cairo surface.  <a href="#17d8f600aedba416bb640ac841494bde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classCairo_1_1Surface.html#d176eb7343b5902df3c19f9f56e59fb4">cobject</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#f45e0ec675af4bb7259df99d202ac83c">cobj</a> () const </td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides acces to the underlying C cairo surface.  <a href="#f45e0ec675af4bb7259df99d202ac83c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#c471fbf586ba579565c6d876f9164717">create</a> (const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt; other, <a class="el" href="namespaceCairo.html#1f0f5d82599dfeabbeb2396dbfd767d0">Content</a> content, int width, int height)</td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new surface that is as compatible as possible with an existing surface.  <a href="#c471fbf586ba579565c6d876f9164717"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCairo_1_1Surface.html#d176eb7343b5902df3c19f9f56e59fb4">cobject</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#8c9aea28f0d1f6c2dcb507a2c7bb027c">m_cobject</a></td></tr>

<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying C cairo surface type that is wrapped by this <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation...">Surface</a>.  <a href="#8c9aea28f0d1f6c2dcb507a2c7bb027c"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A cairo surface represents an image, either as the destination of a drawing operation or as source when drawing onto another surface. 
<p>
There are different subtypes of cairo surface for different drawing backends. This class is a base class for all subtypes and should not be used directly<p>
Surfaces are reference-counted objects that should be used via <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">Cairo::RefPtr</a>. <hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="d176eb7343b5902df3c19f9f56e59fb4"></a><!-- doxytag: member="Cairo::Surface::cobject" ref="d176eb7343b5902df3c19f9f56e59fb4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cairo_surface_t <a class="el" href="classCairo_1_1Surface.html#d176eb7343b5902df3c19f9f56e59fb4">Cairo::Surface::cobject</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The underlying C cairo surface type. 
<p>

</div>
</div><p>
<a class="anchor" name="f66be8453e3fc558ea1282a911bf60e2"></a><!-- doxytag: member="Cairo::Surface::SlotReadFunc" ref="f66be8453e3fc558ea1282a911bf60e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef sigc::slot&lt;ErrorStatus, unsigned char* , unsigned int &gt; <a class="el" href="classCairo_1_1Surface.html#f66be8453e3fc558ea1282a911bf60e2">Cairo::Surface::SlotReadFunc</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the type of function which is called when a backend needs to read data from an input stream. 
<p>
It is passed the buffer to read the data into and the length of the data in bytes. The read function should return CAIRO_STATUS_SUCCESS if all the data was successfully read, CAIRO_STATUS_READ_ERROR otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&#160;</td><td>the buffer into which to read the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>the amount of data to read </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the status code of the read operation </dd></dl>

</div>
</div><p>
<a class="anchor" name="02fb9416d466b762bc5845b0ae204f49"></a><!-- doxytag: member="Cairo::Surface::SlotWriteFunc" ref="02fb9416d466b762bc5845b0ae204f49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef sigc::slot&lt;ErrorStatus, const unsigned char* , unsigned int &gt; <a class="el" href="classCairo_1_1Surface.html#02fb9416d466b762bc5845b0ae204f49">Cairo::Surface::SlotWriteFunc</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For example: <code> ErrorStatus my_write_func(unsigned char* data, unsigned int length); </code>. 
<p>
This is the type of function which is called when a backend needs to write data to an output stream. It is passed the data to write and the length of the data in bytes. The write function should return CAIRO_STATUS_SUCCESS if all the data was successfully written, CAIRO_STATUS_WRITE_ERROR otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&#160;</td><td>the buffer containing the data to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&#160;</td><td>the amount of data to write </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the status code of the write operation </dd></dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="47b90669a5a85d187cc0d28dc99915c8"></a><!-- doxytag: member="Cairo::Surface::Surface" ref="47b90669a5a85d187cc0d28dc99915c8" args="(cairo_surface_t *cobject, bool has_reference=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cairo::Surface::Surface           </td>
          <td>(</td>
          <td class="paramtype">cairo_surface_t *&#160;</td>
          <td class="paramname"> <em>cobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>has_reference</em> = <code>false</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a C++ wrapper for the C instance. 
<p>
This C++ instance should then be given to a <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">RefPtr</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cobject</em>&#160;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>has_reference</em>&#160;</td><td>Whether we already have a reference. Otherwise, the constructor will take an extra reference. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="64ca52e9e8e9a64358ff85e6ef0d93c1"></a><!-- doxytag: member="Cairo::Surface::~Surface" ref="64ca52e9e8e9a64358ff85e6ef0d93c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Cairo::Surface::~Surface           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f45e0ec675af4bb7259df99d202ac83c"></a><!-- doxytag: member="Cairo::Surface::cobj" ref="f45e0ec675af4bb7259df99d202ac83c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCairo_1_1Surface.html#d176eb7343b5902df3c19f9f56e59fb4">cobject</a>* Cairo::Surface::cobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides acces to the underlying C cairo surface. 
<p>

</div>
</div><p>
<a class="anchor" name="17d8f600aedba416bb640ac841494bde"></a><!-- doxytag: member="Cairo::Surface::cobj" ref="17d8f600aedba416bb640ac841494bde" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Surface.html#d176eb7343b5902df3c19f9f56e59fb4">cobject</a>* Cairo::Surface::cobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides acces to the underlying C cairo surface. 
<p>

</div>
</div><p>
<a class="anchor" name="ae22bcaa9becbf3ca703a380f70c2c0a"></a><!-- doxytag: member="Cairo::Surface::copy_page" ref="ae22bcaa9becbf3ca703a380f70c2c0a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::copy_page           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits the current page for backends that support multiple pages, but doesn't clear it, so that the contents of the current page will be retained for the next page. 
<p>
Use <a class="el" href="classCairo_1_1Surface.html#d318acd86c1875854ef4e1e2867052c3" title="Emits and clears the current page for backends that support multiple pages.">show_page()</a> if you want to get an empty page after the emission.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="c471fbf586ba579565c6d876f9164717"></a><!-- doxytag: member="Cairo::Surface::create" ref="c471fbf586ba579565c6d876f9164717" args="(const RefPtr&lt; Surface &gt; other, Content content, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt;<a class="el" href="classCairo_1_1Surface.html">Surface</a>&gt; Cairo::Surface::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&#160;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceCairo.html#1f0f5d82599dfeabbeb2396dbfd767d0">Content</a>&#160;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>height</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new surface that is as compatible as possible with an existing surface. 
<p>
The new surface will use the same backend as other unless that is not possible for some reason.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&#160;</td><td>an existing surface used to select the backend of the new surface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&#160;</td><td>the content for the new surface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&#160;</td><td>width of the new surface, (in device-space units) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&#160;</td><td>height of the new surface (in device-space units) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">RefPtr</a> to the newly allocated surface. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8d8afee4ddb4935b85698f27099646a0"></a><!-- doxytag: member="Cairo::Surface::finish" ref="8d8afee4ddb4935b85698f27099646a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::finish           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function finishes the surface and drops all references to external resources. 
<p>
For example, for the Xlib backend it means that cairo will no longer access the drawable, which can be freed. After calling <a class="el" href="classCairo_1_1Surface.html#8d8afee4ddb4935b85698f27099646a0" title="This function finishes the surface and drops all references to external resources...">finish()</a> the only valid operations on a surface are getting and setting user data and referencing and destroying it. Further drawing to the surface will not affect the surface but will instead trigger a CAIRO_STATUS_SURFACE_FINISHED error.<p>
When the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation...">Surface</a> is destroyed, cairo will call <a class="el" href="classCairo_1_1Surface.html#8d8afee4ddb4935b85698f27099646a0" title="This function finishes the surface and drops all references to external resources...">finish()</a> if it hasn't been called already, before freeing the resources associated with the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation...">Surface</a>. 
</div>
</div><p>
<a class="anchor" name="8f95678918fb40bae15f8aad2adb6ef2"></a><!-- doxytag: member="Cairo::Surface::flush" ref="8f95678918fb40bae15f8aad2adb6ef2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::flush           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do any pending drawing for the surface and also restore any temporary modifications cairo has made to the surface's state. 
<p>
This function must be called before switching from drawing on the surface with cairo to drawing on it directly with native APIs. If the surface doesn't support direct access, then this function does nothing. 
</div>
</div><p>
<a class="anchor" name="5fe39669b1d4239f3e4f73a8bf5105a5"></a><!-- doxytag: member="Cairo::Surface::get_content" ref="5fe39669b1d4239f3e4f73a8bf5105a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCairo.html#1f0f5d82599dfeabbeb2396dbfd767d0">Content</a> Cairo::Surface::get_content           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the content type of surface which indicates whether the surface contains color and/or alpha information. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.8 </dd></dl>

</div>
</div><p>
<a class="anchor" name="5861783d0f5f3b396f52791a93e668fe"></a><!-- doxytag: member="Cairo::Surface::get_device_offset" ref="5861783d0f5f3b396f52791a93e668fe" args="(double &amp;x_offset, double &amp;y_offset) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::get_device_offset           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>y_offset</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a previous device offset set by <a class="el" href="classCairo_1_1Surface.html#957e290a548d3cba65aa9e3fd0c86180" title="Sets an offset that is added to the device coordinates determined by the CTM when...">set_device_offset()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="a3a8d5a2b5c91d11f7758d0a67f6093a"></a><!-- doxytag: member="Cairo::Surface::get_fallback_resolution" ref="a3a8d5a2b5c91d11f7758d0a67f6093a" args="(double &amp;x_pixels_per_inch, double &amp;y_pixels_per_inch) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::get_fallback_resolution           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>x_pixels_per_inch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>y_pixels_per_inch</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the previous fallback resolution set by <a class="el" href="classCairo_1_1Surface.html#c8caca30702fe2bd69ae89929ee784e8" title="Sets the fallback resolution of the image in dots per inch.">set_fallback_resolution()</a>, or default fallback resolution if never set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x_pixels_per_inch</em>&#160;</td><td>horizontal pixels per inch </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y_pixels_per_inch</em>&#160;</td><td>vertical pixels per inch</td></tr>
  </table>
</dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.8 </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e3dd712e398719315bbd89efe9af0b2"></a><!-- doxytag: member="Cairo::Surface::get_font_options" ref="7e3dd712e398719315bbd89efe9af0b2" args="(FontOptions &amp;options) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::get_font_options           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCairo_1_1FontOptions.html">FontOptions</a>&amp;&#160;</td>
          <td class="paramname"> <em>options</em>          </td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the default font rendering options for the surface. 
<p>
This allows display surfaces to report the correct subpixel order for rendering on them, print surfaces to disable hinting of metrics and so forth. The result can then be used with cairo_scaled_font_create().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>options</em>&#160;</td><td>a <a class="el" href="classCairo_1_1FontOptions.html" title="How a font should be rendered.">FontOptions</a> object into which to store the retrieved options. All existing values are overwritten </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ee0760ea1895f5e6c8f6673f83cc072"></a><!-- doxytag: member="Cairo::Surface::get_type" ref="7ee0760ea1895f5e6c8f6673f83cc072" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCairo.html#f11d962e38a38a2d92fc1473fbe92549">SurfaceType</a> Cairo::Surface::get_type           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e4e133bf758c85195db6d3ccfbe1d54a"></a><!-- doxytag: member="Cairo::Surface::has_show_text_glyphs" ref="e4e133bf758c85195db6d3ccfbe1d54a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cairo::Surface::has_show_text_glyphs           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the surface supports sophisticated <a class="el" href="classCairo_1_1Context.html#45723fd605cc2343ab46cf603d330002">Context::show_text_glyphs()</a> operations. 
<p>
That is, whether it actually uses the provided text and cluster data to a <a class="el" href="classCairo_1_1Context.html#45723fd605cc2343ab46cf603d330002">Context::show_text_glyphs()</a> call.<p>
Note: Even if this function returns FALSE, a <a class="el" href="classCairo_1_1Context.html#45723fd605cc2343ab46cf603d330002">Context::show_text_glyphs()</a> operation targeted at this surface will still succeed. It just will act like a <a class="el" href="classCairo_1_1Context.html#f51f2c2ff72e8af66abeea3d15d25553">Context::show_glyphs()</a> operation. Users can use this function to avoid computing UTF-8 text and cluster mapping if the target surface does not use it.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.8 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1dbf3a036b7dc7c09fc86996ea1ee61f"></a><!-- doxytag: member="Cairo::Surface::mark_dirty" ref="1dbf3a036b7dc7c09fc86996ea1ee61f" args="(int x, int y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::mark_dirty           </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>height</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks a rectangular area of the given surface dirty. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&#160;</td><td>X coordinate of dirty rectangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>Y coordinate of dirty rectangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&#160;</td><td>width of dirty rectangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&#160;</td><td>height of dirty rectangle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="77b1f860cc55f4ad168e100108e0b7bb"></a><!-- doxytag: member="Cairo::Surface::mark_dirty" ref="77b1f860cc55f4ad168e100108e0b7bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::mark_dirty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells cairo to consider the data buffer dirty. 
<p>
In particular, if you've created an <a class="el" href="classCairo_1_1ImageSurface.html" title="Image surfaces provide the ability to render to memory buffers either allocated by...">ImageSurface</a> with a data buffer that you've allocated yourself and you draw to that data buffer using means other than cairo, you must call <a class="el" href="classCairo_1_1Surface.html#77b1f860cc55f4ad168e100108e0b7bb" title="Tells cairo to consider the data buffer dirty.">mark_dirty()</a> before doing any additional drawing to that surface with cairo.<p>
Note that if you do draw to the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation...">Surface</a> outside of cairo, you must call <a class="el" href="classCairo_1_1Surface.html#8f95678918fb40bae15f8aad2adb6ef2" title="Do any pending drawing for the surface and also restore any temporary modifications...">flush()</a> before doing the drawing. 
</div>
</div><p>
<a class="anchor" name="957e290a548d3cba65aa9e3fd0c86180"></a><!-- doxytag: member="Cairo::Surface::set_device_offset" ref="957e290a548d3cba65aa9e3fd0c86180" args="(double x_offset, double y_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::set_device_offset           </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>y_offset</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface. 
<p>
One use case for this function is when we want to create a <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation...">Surface</a> that redirects drawing for a portion of an onscreen surface to an offscreen surface in a way that is completely invisible to the user of the cairo API. Setting a transformation via cairo_translate() isn't sufficient to do this, since functions like <a class="el" href="classCairo_1_1Context.html#0c7acaaf16d4740cd7fee2298bf2b5c4" title="Transform a coordinate from device space to user space by multiplying the given point...">Cairo::Context::device_to_user()</a> will expose the hidden offset.<p>
Note that the offset only affects drawing to the surface, not using the surface in a surface pattern.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x_offset</em>&#160;</td><td>the offset in the X direction, in device units </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y_offset</em>&#160;</td><td>the offset in the Y direction, in device units </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c8caca30702fe2bd69ae89929ee784e8"></a><!-- doxytag: member="Cairo::Surface::set_fallback_resolution" ref="c8caca30702fe2bd69ae89929ee784e8" args="(double x_pixels_per_inch, double y_pixels_per_inch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::set_fallback_resolution           </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>x_pixels_per_inch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>y_pixels_per_inch</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the fallback resolution of the image in dots per inch. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x_pixels_per_inch</em>&#160;</td><td>Pixels per inch in the x direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y_pixels_per_inch</em>&#160;</td><td>Pixels per inch in the y direction </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d318acd86c1875854ef4e1e2867052c3"></a><!-- doxytag: member="Cairo::Surface::show_page" ref="d318acd86c1875854ef4e1e2867052c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::show_page           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits and clears the current page for backends that support multiple pages. 
<p>
Use <a class="el" href="classCairo_1_1Surface.html#ae22bcaa9becbf3ca703a380f70c2c0a" title="Emits the current page for backends that support multiple pages, but doesn&#39;t...">copy_page()</a> if you don't want to clear the page.<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="83763b7906a666b095ce376271455457"></a><!-- doxytag: member="Cairo::Surface::write_to_png" ref="83763b7906a666b095ce376271455457" args="(cairo_write_func_t write_func, void *closure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::write_to_png           </td>
          <td>(</td>
          <td class="paramtype">cairo_write_func_t&#160;</td>
          <td class="paramname"> <em>write_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>closure</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="deprecated" compact><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use write_to_png_stream instead </dd></dl>

</div>
</div><p>
<a class="anchor" name="153405d271814ab4d47b90a1c36d2370"></a><!-- doxytag: member="Cairo::Surface::write_to_png" ref="153405d271814ab4d47b90a1c36d2370" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::write_to_png           </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00218.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the contents of surface to a new file filename as a PNG image. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For this function to be available, cairo must have been compiled with PNG support</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&#160;</td><td>the name of a file to write to </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b3eca5bc13abe27f470fdf08134269bb"></a><!-- doxytag: member="Cairo::Surface::write_to_png_stream" ref="b3eca5bc13abe27f470fdf08134269bb" args="(const SlotWriteFunc &amp;write_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::write_to_png_stream           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1Surface.html#02fb9416d466b762bc5845b0ae204f49">SlotWriteFunc</a>&amp;&#160;</td>
          <td class="paramname"> <em>write_func</em>          </td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation...">Surface</a> to the write function. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For this function to be available, cairo must have been compiled with PNG support</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>write_func</em>&#160;</td><td>The function to be called when the backend needs to write data to an output stream</td></tr>
  </table>
</dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.8 </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="8c9aea28f0d1f6c2dcb507a2c7bb027c"></a><!-- doxytag: member="Cairo::Surface::m_cobject" ref="8c9aea28f0d1f6c2dcb507a2c7bb027c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Surface.html#d176eb7343b5902df3c19f9f56e59fb4">cobject</a>* <a class="el" href="classCairo_1_1Surface.html#8c9aea28f0d1f6c2dcb507a2c7bb027c">Cairo::Surface::m_cobject</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The underlying C cairo surface type that is wrapped by this <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation...">Surface</a>. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>cairomm/surface.h</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 13 11:40:14 2009 for cairomm by&#160;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
