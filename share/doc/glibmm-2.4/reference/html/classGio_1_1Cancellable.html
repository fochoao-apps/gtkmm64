<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>glibmm: Gio::Cancellable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>
  </div>
</div>
<div class="contents">
<h1>Gio::Cancellable Class Reference</h1><!-- doxytag: class="Gio::Cancellable" --><!-- doxytag: inherits="Glib::Object" -->
<p>Allows actions to be cancelled. <a href="#_details">More...</a></p>

<p><code>#include &lt;giomm/cancellable.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::Cancellable:</div>
<div class="dynsection">
<div class="center"><img src="classGio_1_1Cancellable__inherit__graph.png" border="0" usemap="#Gio_1_1Cancellable_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1Cancellable_inherit__map" id="Gio_1_1Cancellable_inherit__map">
<area shape="rect" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="21,161,115,188"/><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="5,84,131,111"/><area shape="rect" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="12,7,124,33"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1Cancellable-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a18d005aeefd0da4daab594f4c44ce9cd">SlotCancelledCallback</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a97c7c4d728865129bc6f0cd3f4ecfce7">~Cancellable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GCancellable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ae19ec1e85fd9cd7893914d4d7c20120d">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#ae19ec1e85fd9cd7893914d4d7c20120d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GCancellable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a668176a01f7ad3cc13c7448378f37b41">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a668176a01f7ad3cc13c7448378f37b41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GCancellable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a379e6394bad0fff1eb11e1a160f30235">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a379e6394bad0fff1eb11e1a160f30235"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a47ce5f2f16541b7ae18bc5114b366d8c">is_cancelled</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a cancellable job has been cancelled. <a href="#a47ce5f2f16541b7ae18bc5114b366d8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a80df23049daf594fda884f2932ce3b95">get_fd</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file descriptor for a cancellable job. <a href="#a80df23049daf594fda884f2932ce3b95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a6627893047c8a375324b58e955661395">make_pollfd</a> (GPollFD* pollfd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a PollFD corresponding to <em>cancellable</em>; this can be passed to Glib::poll() and used to poll for cancellation. <a href="#a6627893047c8a375324b58e955661395"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ad8f406bb61e80d382153ebf600822ce2">release_fd</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a resources previously allocated by g_cancellable_get_fd() or g_cancellable_make_pollfd(). <a href="#ad8f406bb61e80d382153ebf600822ce2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a86adae0645cec20d09d1a2903fe46cc0">cancel</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Will set <em>cancellable</em> to cancelled, and will emit the Cancellable::cancelled signal. <a href="#a86adae0645cec20d09d1a2903fe46cc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ad893da5aebfb4baf34ecdbdad7a3608b">push_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes <em>cancellable</em> onto the cancellable stack. <a href="#ad893da5aebfb4baf34ecdbdad7a3608b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a93b5a39447d2b4eb9fb56748cb687fc8">pop_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops <em>cancellable</em> off the cancellable stack (verifying that <em>cancellable</em> is on the top of the stack). <a href="#a93b5a39447d2b4eb9fb56748cb687fc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a2285370aea5d98141e742e73743b9c3e">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets <em>cancellable</em> to its uncancelled state. <a href="#a2285370aea5d98141e742e73743b9c3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ad43ddee749e87373a2dd035f8eb989e6">connect</a> (const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotCancelledCallback</a>&amp; callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to connect to the Cancellable::cancelled signal. <a href="#ad43ddee749e87373a2dd035f8eb989e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aa9277479b4bf0b80090e780e26215713">disconnect</a> (gulong handler_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a handler from a cancellable instance similar to Glib::signal_handler_disconnect(). <a href="#aa9277479b4bf0b80090e780e26215713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">signal_cancelled</a> ()</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a8d59324b4c253f8c890901cd934203a7">create</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aaf923ce91ddf21fc03bf2902e12cd4e1">get_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the top cancellable from the stack. <a href="#aaf923ce91ddf21fc03bf2902e12cd4e1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aab7733b6e915e4ebe280fbb669b6af2a">Cancellable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aff017e200824997b9c26d82f147e078f">on_cancelled</a> ()</td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Gio::Cancellable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ac45875da91c9c870a0f154a8249047c0">wrap</a> (GCancellable* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#ac45875da91c9c870a0f154a8249047c0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Allows actions to be cancelled. </p>
<p><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> is a thread-safe operation cancellation stack used throughout GIO to allow for cancellation of synchronous and asynchronous operations.</p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000019">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a18d005aeefd0da4daab594f4c44ce9cd"></a><!-- doxytag: member="Gio::Cancellable::SlotCancelledCallback" ref="a18d005aeefd0da4daab594f4c44ce9cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;void&gt; <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">Gio::Cancellable::SlotCancelledCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97c7c4d728865129bc6f0cd3f4ecfce7"></a><!-- doxytag: member="Gio::Cancellable::~Cancellable" ref="a97c7c4d728865129bc6f0cd3f4ecfce7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::Cancellable::~Cancellable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab7733b6e915e4ebe280fbb669b6af2a"></a><!-- doxytag: member="Gio::Cancellable::Cancellable" ref="aab7733b6e915e4ebe280fbb669b6af2a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gio::Cancellable::Cancellable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a86adae0645cec20d09d1a2903fe46cc0"></a><!-- doxytag: member="Gio::Cancellable::cancel" ref="a86adae0645cec20d09d1a2903fe46cc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::cancel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Will set <em>cancellable</em> to cancelled, and will emit the Cancellable::cancelled signal. </p>
<p>(However, see the warning about race conditions in the documentation for that signal if you are planning to connect to it.)</p>
<p>This function is thread-safe. In other words, you can safely call it from a thread other than the one running the operation that was passed the <em>cancellable</em>.</p>
<p>The convention within gio is that cancelling an asynchronous operation causes it to complete asynchronously. That is, if you cancel the operation from the same thread in which it is running, then the operation's AsyncReadyCallback will not be invoked until the application returns to the main loop. </p>

</div>
</div>
<a class="anchor" id="ad43ddee749e87373a2dd035f8eb989e6"></a><!-- doxytag: member="Gio::Cancellable::connect" ref="ad43ddee749e87373a2dd035f8eb989e6" args="(const SlotCancelledCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gulong Gio::Cancellable::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotCancelledCallback</a> &amp;&#160;</td>
          <td class="paramname"> <em>callback</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience function to connect to the Cancellable::cancelled signal. </p>
<p>Also handles the race condition that may happen if the cancellable is cancelled right before connecting.</p>
<p><em>callback</em> is called at most once, either directly at the time of the connect if <em>cancellable</em> is already cancelled, or when <em>cancellable</em> is cancelled in some thread.</p>
<p><em>data_destroy_func</em> will be called when the handler is disconnected, or immediately if the cancellable is already cancelled.</p>
<p>See Cancellable::cancelled for details on how to use this.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000009">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&#160;</td><td>The Callback to connect. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&#160;</td><td>Data to pass to <em>callback</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_destroy_func</em>&#160;</td><td>Free function for <em>data</em> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The id of the signal handler or 0 if <em>cancellable</em> has already been cancelled. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d59324b4c253f8c890901cd934203a7"></a><!-- doxytag: member="Gio::Cancellable::create" ref="a8d59324b4c253f8c890901cd934203a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt; Gio::Cancellable::create </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9277479b4bf0b80090e780e26215713"></a><!-- doxytag: member="Gio::Cancellable::disconnect" ref="aa9277479b4bf0b80090e780e26215713" args="(gulong handler_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::disconnect </td>
          <td>(</td>
          <td class="paramtype">gulong&#160;</td>
          <td class="paramname"> <em>handler_id</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a handler from a cancellable instance similar to Glib::signal_handler_disconnect(). </p>
<p>Additionally, in the event that a signal handler is currently running, this call will block until the handler has finished. Calling this function from a Cancellable::cancelled signal handler will therefore result in a deadlock.</p>
<p>This avoids a race condition where a thread cancels at the same time as the cancellable operation is finished and the signal handler is removed. See Cancellable::cancelled for details on how to use this.</p>
<p>If <em>cancellable</em> is <code>0</code> or <em>handler_id</em> is 0 this function does nothing.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000010">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler_id</em>&#160;</td><td>Handler id of the handler to be disconnected, or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf923ce91ddf21fc03bf2902e12cd4e1"></a><!-- doxytag: member="Gio::Cancellable::get_current" ref="aaf923ce91ddf21fc03bf2902e12cd4e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt; Gio::Cancellable::get_current </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the top cancellable from the stack. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> from the top of the stack, or <code>0</code> if the stack is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a80df23049daf594fda884f2932ce3b95"></a><!-- doxytag: member="Gio::Cancellable::get_fd" ref="a80df23049daf594fda884f2932ce3b95" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gio::Cancellable::get_fd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the file descriptor for a cancellable job. </p>
<p>This can be used to implement cancellable operations on Unix systems. The returned fd will turn readable when <em>cancellable</em> is cancelled.</p>
<p>You are not supposed to read from the fd yourself, just check for readable status. Reading to unset the readable status is done with g_cancellable_reset().</p>
<p>After a successful return from this function, you should use g_cancellable_release_fd() to free up resources allocated for the returned file descriptor.</p>
<p>See also g_cancellable_make_pollfd(). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid file descriptor. -1 if the file descriptor is not supported, or on errors. </dd></dl>

</div>
</div>
<a class="anchor" id="a668176a01f7ad3cc13c7448378f37b41"></a><!-- doxytag: member="Gio::Cancellable::gobj" ref="a668176a01f7ad3cc13c7448378f37b41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GCancellable* Gio::Cancellable::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="ae19ec1e85fd9cd7893914d4d7c20120d"></a><!-- doxytag: member="Gio::Cancellable::gobj" ref="ae19ec1e85fd9cd7893914d4d7c20120d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCancellable* Gio::Cancellable::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="a379e6394bad0fff1eb11e1a160f30235"></a><!-- doxytag: member="Gio::Cancellable::gobj_copy" ref="a379e6394bad0fff1eb11e1a160f30235" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCancellable* Gio::Cancellable::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a47ce5f2f16541b7ae18bc5114b366d8c"></a><!-- doxytag: member="Gio::Cancellable::is_cancelled" ref="a47ce5f2f16541b7ae18bc5114b366d8c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Cancellable::is_cancelled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a cancellable job has been cancelled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>cancellable</em> is cancelled, <code>false</code> if called with <code>0</code> or if item is not cancelled. </dd></dl>

</div>
</div>
<a class="anchor" id="a6627893047c8a375324b58e955661395"></a><!-- doxytag: member="Gio::Cancellable::make_pollfd" ref="a6627893047c8a375324b58e955661395" args="(GPollFD *pollfd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Cancellable::make_pollfd </td>
          <td>(</td>
          <td class="paramtype">GPollFD *&#160;</td>
          <td class="paramname"> <em>pollfd</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a PollFD corresponding to <em>cancellable</em>; this can be passed to Glib::poll() and used to poll for cancellation. </p>
<p>This is useful both for unix systems without a native poll and for portability to windows.</p>
<p>When this function returns <code>true</code>, you should use g_cancellable_release_fd() to free up resources allocated for the <em>pollfd</em>. After a <code>false</code> return, do not call g_cancellable_release_fd().</p>
<p>If this function returns <code>false</code>, either no <em>cancellable</em> was given or resource limits prevent this function from allocating the necessary structures for polling. (On Linux, you will likely have reached the maximum number of file descriptors.) The suggested way to handle these cases is to ignore the <em>cancellable</em>.</p>
<p>You are not supposed to read from the fd yourself, just check for readable status. Reading to unset the readable status is done with g_cancellable_reset().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000007">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pollfd</em>&#160;</td><td>A pointer to a PollFD. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>pollfd</em> was successfully initialized, <code>false</code> on failure to prepare the cancellable. </dd></dl>

</div>
</div>
<a class="anchor" id="aff017e200824997b9c26d82f147e078f"></a><!-- doxytag: member="Gio::Cancellable::on_cancelled" ref="aff017e200824997b9c26d82f147e078f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gio::Cancellable::on_cancelled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a93b5a39447d2b4eb9fb56748cb687fc8"></a><!-- doxytag: member="Gio::Cancellable::pop_current" ref="a93b5a39447d2b4eb9fb56748cb687fc8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::pop_current </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pops <em>cancellable</em> off the cancellable stack (verifying that <em>cancellable</em> is on the top of the stack). </p>

</div>
</div>
<a class="anchor" id="ad893da5aebfb4baf34ecdbdad7a3608b"></a><!-- doxytag: member="Gio::Cancellable::push_current" ref="ad893da5aebfb4baf34ecdbdad7a3608b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::push_current </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pushes <em>cancellable</em> onto the cancellable stack. </p>
<p>The current cancllable can then be recieved using g_cancellable_get_current().</p>
<p>This is useful when implementing cancellable operations in code that does not allow you to pass down the cancellable object.</p>
<p>This is typically called automatically by e.g. <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> operations, so you rarely have to call this yourself. </p>

</div>
</div>
<a class="anchor" id="ad8f406bb61e80d382153ebf600822ce2"></a><!-- doxytag: member="Gio::Cancellable::release_fd" ref="ad8f406bb61e80d382153ebf600822ce2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::release_fd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases a resources previously allocated by g_cancellable_get_fd() or g_cancellable_make_pollfd(). </p>
<p>For compatibility reasons with older releases, calling this function is not strictly required, the resources will be automatically freed when the <em>cancellable</em> is finalized. However, the <em>cancellable</em> will block scarce file descriptors until it is finalized if this function is not called. This can cause the application to run out of file descriptors when many Cancellables are used at the same time.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000008">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2285370aea5d98141e742e73743b9c3e"></a><!-- doxytag: member="Gio::Cancellable::reset" ref="a2285370aea5d98141e742e73743b9c3e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Cancellable::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets <em>cancellable</em> to its uncancelled state. </p>

</div>
</div>
<a class="anchor" id="a5a34d4782ccec014684c4eb6c20cf0a6"></a><!-- doxytag: member="Gio::Cancellable::signal_cancelled" ref="a5a34d4782ccec014684c4eb6c20cf0a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt; Gio::Cancellable::signal_cancelled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Prototype:</b></dt><dd><code>void on_my_cancelled()</code> </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ac45875da91c9c870a0f154a8249047c0"></a><!-- doxytag: member="Gio::Cancellable::wrap" ref="ac45875da91c9c870a0f154a8249047c0" args="(GCancellable *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Gio::Cancellable</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GCancellable *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&#160;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&#160;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Mon May 3 23:46:26 2010 for glibmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
