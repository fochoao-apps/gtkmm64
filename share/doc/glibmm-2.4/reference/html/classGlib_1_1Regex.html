<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>glibmm: Glib::Regex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceGlib.html">Glib</a>::<a class="el" href="classGlib_1_1Regex.html">Regex</a>
  </div>
</div>
<div class="contents">
<h1>Glib::Regex Class Reference</h1><!-- doxytag: class="Glib::Regex" -->
<p>Perl-compatible regular expressions - matches strings against regular expressions. <a href="#_details">More...</a></p>

<p><code>#include &lt;glibmm/regex.h&gt;</code></p>

<p><a href="classGlib_1_1Regex-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a6099ec7a4be34e4fec017a9d18eeb7f4">reference</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count for this object. <a href="#a6099ec7a4be34e4fec017a9d18eeb7f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a661a9b85f52dbaaa68a6495ace7df50a">unreference</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count for this object. <a href="#a661a9b85f52dbaaa68a6495ace7df50a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GRegex*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a640d1c5b6bc6ff05461dbf11b97e4477">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. <a href="#a640d1c5b6bc6ff05461dbf11b97e4477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GRegex*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ae5c9e3ee8fd94e728128ff8eacb138c1">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. <a href="#ae5c9e3ee8fd94e728128ff8eacb138c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GRegex*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a6766b1090ea2e97757a5585aca14f926">gobj_copy</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a6766b1090ea2e97757a5585aca14f926"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a802f0517b6bb5d72e55bc1dcaa8174a5">get_pattern</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pattern string associated with <em>regex</em>, i.e. a copy of the string passed to g_regex_new(). <a href="#a802f0517b6bb5d72e55bc1dcaa8174a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ac7123b6f880561ff94134c808a254387">get_max_backref</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the highest back reference in the pattern, or 0 if the pattern does not contain back references. <a href="#ac7123b6f880561ff94134c808a254387"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a891b0f5b73a2beb390330778a0114c94">get_capture_count</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of capturing subpatterns in the pattern. <a href="#a891b0f5b73a2beb390330778a0114c94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a033e3e0480fc5904d307f06a35e3240b">get_string_number</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of the subexpression named <em>name</em>. <a href="#a033e3e0480fc5904d307f06a35e3240b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ad19516ab8cbcad727a159160a50bf26e">match</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#acbbd6f902b679b6b34554099a2ef67ef">match</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a6e0224ad096ba88c94e6e648a619f163">match</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, gssize string_len, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a8e2a2daa7f18c41ca37080cdd4842fae">match_all</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#adf0dc5f15631c6a090c5724bfa71f4bf">match_all</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a2e393570c407f42cbf4e223fab19f499">match_all</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, gssize string_len, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ArrayHandle.html">Glib::StringArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a447bbb8dc8ca457d1c1a4ab0740ced7e">split</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the string on the pattern, and returns an array of the tokens. <a href="#a447bbb8dc8ca457d1c1a4ab0740ced7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ArrayHandle.html">Glib::StringArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ace0220e0ed2d7bd7771030e360e5141f">split</a> (const gchar*<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, gssize string_len, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0), int max_tokens=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the string on the pattern, and returns an array of the tokens. <a href="#ace0220e0ed2d7bd7771030e360e5141f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ArrayHandle.html">Glib::StringArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a3f2f68542607519a358dd0ada1b5e3d5">split</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options, int max_tokens) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ae9f40c233d33361814252f8bfb00a716">replace</a> (const gchar*<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, gssize string_len, int start_position, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of the pattern in <em>regex</em> with the replacement text. <a href="#ae9f40c233d33361814252f8bfb00a716"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#add3848dcec1b22547ab57fddbfdaec1d">replace</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, int start_position, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a4bccbbffa1c84249b35201ee6e6f39c9">replace_literal</a> (const gchar*<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, gssize string_len, int start_position, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of the pattern in <em>regex</em> with the replacement text. <a href="#a4bccbbffa1c84249b35201ee6e6f39c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a6660f8fcf2ec8a6e90a7ecc85ced0e2a">replace_literal</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, int start_position, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ac5a2cf889ebf233c5d467b3816c8d533">replace_eval</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, gssize string_len, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options, GRegexEvalCallback eval, gpointer user_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces occurrences of the pattern in regex with the output of <em>eval</em> for that occurrence. <a href="#ac5a2cf889ebf233c5d467b3816c8d533"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Regex.html">Glib::Regex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a09d723a3b495453399d9f685b528727a">create</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; pattern, <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> compile_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> &gt;(0), <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#abc2c9b4f7d042a125d0d65fb16b71ff1">escape_string</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a74905e31f14819b84c9e9cb53c79ca6c">match_simple</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; pattern, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> compile_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> &gt;(0), <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans for a match in <em>string</em> for <em>pattern</em>. <a href="#a74905e31f14819b84c9e9cb53c79ca6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::StringArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#aa0911a410fa5295667d54e900cce7f10">split_simple</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; pattern, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01108.html#af4d08898cac5ae6fe1d0a15a6f90d271">string</a>, <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> compile_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> &gt;(0), <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the string on the pattern, and returns an array of the tokens. <a href="#aa0911a410fa5295667d54e900cce7f10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a54071d7bdd63db75099445fe0c84580c">check_replacement</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, gboolean* has_references)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <em>replacement</em> is a valid replacement string (see g_regex_replace()), i.e. that all escape sequences in it are valid. <a href="#a54071d7bdd63db75099445fe0c84580c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ad4d1d89ce7ff8a5b9294e9d8035319a8">Regex</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#afd2c035dacc69786e469f56db2ea3899">operator delete</a> (void*, size_t)</td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Regex.html">Glib::Regex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#aa502a39684fb9d59dc689da8bb9d9da8">wrap</a> (GRegex* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#aa502a39684fb9d59dc689da8bb9d9da8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Perl-compatible regular expressions - matches strings against regular expressions. </p>
<p>The <a class="el" href="classGlib_1_1Regex.html" title="Perl-compatible regular expressions - matches strings against regular expressions...">Glib::Regex</a> functions implement regular expression pattern matching using syntax and semantics similar to Perl regular expression.</p>
<p>Some functions accept a start_position argument, setting it differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion. For example, consider the pattern "\Biss\B" which finds occurrences of "iss" in the middle of words. ("\B" matches only if the current position in the subject is not a word boundary.) When applied to the string "Mississipi" from the fourth byte, namely "issipi", it does not match, because "\B" is always false at the start of the subject, which is deemed to be a word boundary. However, if the entire string is passed , but with start_position set to 4, it finds the second occurrence of "iss" because it is able to look behind the starting point to discover that it is preceded by a letter.</p>
<p>Note that, unless you set the REGEX_RAW flag, all the strings passed to these functions must be encoded in UTF-8. The lengths and the positions inside the strings are in bytes and not in characters, so, for instance, "\xc3\xa0" (i.e. "à") is two bytes long but it is treated as a single character. If you set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is treated as a character, so "\xc3\xa0" is two bytes and two characters long.</p>
<p>When matching a pattern, "\n" matches only against a "\n" character in the string, and "\r" matches only a "\r" character. To match any newline sequence use "\R". This particular group matches either the two-character sequence CR + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"), VT (vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028), or PS (paragraph separator, U+2029).</p>
<p>The behaviour of the dot, circumflex, and dollar metacharacters are affected by newline characters, the default is to recognize any newline character (the same characters recognized by "\R"). This can be changed with REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options, and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR, REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These settings are also relevant when compiling a pattern if REGEX_EXTENDED is set, and an unescaped "#" outside a character class is encountered. This indicates a comment that lasts until after the next newline.</p>
<p>Creating and manipulating the same <a class="el" href="classGlib_1_1Regex.html" title="Perl-compatible regular expressions - matches strings against regular expressions...">Glib::Regex</a> class from different threads is not a problem as <a class="el" href="classGlib_1_1Regex.html" title="Perl-compatible regular expressions - matches strings against regular expressions...">Glib::Regex</a> does not modify its internal state between creation and destruction, on the other hand Glib::MatchInfo is not threadsafe.</p>
<p>The regular expressions low level functionalities are obtained through the excellent PCRE library written by Philip Hazel.</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000013">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad4d1d89ce7ff8a5b9294e9d8035319a8"></a><!-- doxytag: member="Glib::Regex::Regex" ref="ad4d1d89ce7ff8a5b9294e9d8035319a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::Regex::Regex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a54071d7bdd63db75099445fe0c84580c"></a><!-- doxytag: member="Glib::Regex::check_replacement" ref="a54071d7bdd63db75099445fe0c84580c" args="(const Glib::ustring &amp;replacement, gboolean *has_references)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Glib::Regex::check_replacement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean *&#160;</td>
          <td class="paramname"> <em>has_references</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether <em>replacement</em> is a valid replacement string (see g_regex_replace()), i.e. that all escape sequences in it are valid. </p>
<p>If <em>has_references</em> is not <code>0</code> then <em>replacement</em> is checked for pattern references. For instance, replacement text 'foo<code>\n</code>' does not contain references and may be evaluated without information about actual match, but '' (whole match followed by first subpattern) requires valid MatchInfo object.</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000025">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&#160;</td><td>The replacement string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>has_references</em>&#160;</td><td>Location to store information about references in <em>replacement</em> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether <em>replacement</em> is a valid replacement string. </dd></dl>

</div>
</div>
<a class="anchor" id="a09d723a3b495453399d9f685b528727a"></a><!-- doxytag: member="Glib::Regex::create" ref="a09d723a3b495453399d9f685b528727a" args="(const Glib::ustring &amp;pattern, RegexCompileFlags compile_options=static_cast&lt; RegexCompileFlags &gt;(0), RegexMatchFlags match_options=static_cast&lt; RegexMatchFlags &gt;(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Regex.html">Glib::Regex</a>&gt; Glib::Regex::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;</td>
          <td class="paramname"> <em>compile_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abc2c9b4f7d042a125d0d65fb16b71ff1"></a><!-- doxytag: member="Glib::Regex::escape_string" ref="abc2c9b4f7d042a125d0d65fb16b71ff1" args="(const Glib::ustring &amp;string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::escape_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a891b0f5b73a2beb390330778a0114c94"></a><!-- doxytag: member="Glib::Regex::get_capture_count" ref="a891b0f5b73a2beb390330778a0114c94" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Glib::Regex::get_capture_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of capturing subpatterns in the pattern. </p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000016">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of capturing subpatterns. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7123b6f880561ff94134c808a254387"></a><!-- doxytag: member="Glib::Regex::get_max_backref" ref="ac7123b6f880561ff94134c808a254387" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Glib::Regex::get_max_backref </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of the highest back reference in the pattern, or 0 if the pattern does not contain back references. </p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000015">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of the highest back reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a802f0517b6bb5d72e55bc1dcaa8174a5"></a><!-- doxytag: member="Glib::Regex::get_pattern" ref="a802f0517b6bb5d72e55bc1dcaa8174a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::get_pattern </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pattern string associated with <em>regex</em>, i.e. a copy of the string passed to g_regex_new(). </p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000014">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pattern of <em>regex</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a033e3e0480fc5904d307f06a35e3240b"></a><!-- doxytag: member="Glib::Regex::get_string_number" ref="a033e3e0480fc5904d307f06a35e3240b" args="(const Glib::ustring &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Glib::Regex::get_string_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of the subexpression named <em>name</em>. </p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000017">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&#160;</td><td>Name of the subexpression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of the subexpression or -1 if <em>name</em> does not exists. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5c9e3ee8fd94e728128ff8eacb138c1"></a><!-- doxytag: member="Glib::Regex::gobj" ref="ae5c9e3ee8fd94e728128ff8eacb138c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GRegex* Glib::Regex::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. </p>

</div>
</div>
<a class="anchor" id="a640d1c5b6bc6ff05461dbf11b97e4477"></a><!-- doxytag: member="Glib::Regex::gobj" ref="a640d1c5b6bc6ff05461dbf11b97e4477" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GRegex* Glib::Regex::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. </p>

</div>
</div>
<a class="anchor" id="a6766b1090ea2e97757a5585aca14f926"></a><!-- doxytag: member="Glib::Regex::gobj_copy" ref="a6766b1090ea2e97757a5585aca14f926" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GRegex* Glib::Regex::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a6e0224ad096ba88c94e6e648a619f163"></a><!-- doxytag: member="Glib::Regex::match" ref="a6e0224ad096ba88c94e6e648a619f163" args="(const Glib::ustring &amp;string, gssize string_len, int start_position, RegexMatchFlags match_options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"> <em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acbbd6f902b679b6b34554099a2ef67ef"></a><!-- doxytag: member="Glib::Regex::match" ref="acbbd6f902b679b6b34554099a2ef67ef" args="(const Glib::ustring &amp;string, int start_position, RegexMatchFlags match_options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad19516ab8cbcad727a159160a50bf26e"></a><!-- doxytag: member="Glib::Regex::match" ref="ad19516ab8cbcad727a159160a50bf26e" args="(const Glib::ustring &amp;string, RegexMatchFlags match_options=static_cast&lt; RegexMatchFlags &gt;(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e393570c407f42cbf4e223fab19f499"></a><!-- doxytag: member="Glib::Regex::match_all" ref="a2e393570c407f42cbf4e223fab19f499" args="(const Glib::ustring &amp;string, gssize string_len, int start_position, RegexMatchFlags match_options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"> <em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adf0dc5f15631c6a090c5724bfa71f4bf"></a><!-- doxytag: member="Glib::Regex::match_all" ref="adf0dc5f15631c6a090c5724bfa71f4bf" args="(const Glib::ustring &amp;string, int start_position, RegexMatchFlags match_options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e2a2daa7f18c41ca37080cdd4842fae"></a><!-- doxytag: member="Glib::Regex::match_all" ref="a8e2a2daa7f18c41ca37080cdd4842fae" args="(const Glib::ustring &amp;string, RegexMatchFlags match_options=static_cast&lt; RegexMatchFlags &gt;(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74905e31f14819b84c9e9cb53c79ca6c"></a><!-- doxytag: member="Glib::Regex::match_simple" ref="a74905e31f14819b84c9e9cb53c79ca6c" args="(const Glib::ustring &amp;pattern, const Glib::ustring &amp;string, RegexCompileFlags compile_options=static_cast&lt; RegexCompileFlags &gt;(0), RegexMatchFlags match_options=static_cast&lt; RegexMatchFlags &gt;(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Glib::Regex::match_simple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;</td>
          <td class="paramname"> <em>compile_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scans for a match in <em>string</em> for <em>pattern</em>. </p>
<p>This function is equivalent to g_regex_match() but it does not require to compile the pattern with g_regex_new(), avoiding some lines of code when you need just to do a match without extracting substrings, capture counts, and so on.</p>
<p>If this function is to be called on the same <em>pattern</em> more than once, it's more efficient to compile the pattern once with g_regex_new() and then use g_regex_match().</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000018">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&#160;</td><td>The regular expression. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>string</em>&#160;</td><td>The string to scan for matches. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compile_options</em>&#160;</td><td>Compile options for the regular expression, or 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_options</em>&#160;</td><td>Match options, or 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the string matched, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afd2c035dacc69786e469f56db2ea3899"></a><!-- doxytag: member="Glib::Regex::operator delete" ref="afd2c035dacc69786e469f56db2ea3899" args="(void *, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Regex::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6099ec7a4be34e4fec017a9d18eeb7f4"></a><!-- doxytag: member="Glib::Regex::reference" ref="a6099ec7a4be34e4fec017a9d18eeb7f4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Regex::reference </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment the reference count for this object. </p>
<p>You should never need to do this manually - use the object via a <a class="el" href="classGlib_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">RefPtr</a> instead. </p>

</div>
</div>
<a class="anchor" id="add3848dcec1b22547ab57fddbfdaec1d"></a><!-- doxytag: member="Glib::Regex::replace" ref="add3848dcec1b22547ab57fddbfdaec1d" args="(const Glib::ustring &amp;string, int start_position, const Glib::ustring &amp;replacement, RegexMatchFlags match_options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9f40c233d33361814252f8bfb00a716"></a><!-- doxytag: member="Glib::Regex::replace" ref="ae9f40c233d33361814252f8bfb00a716" args="(const gchar *string, gssize string_len, int start_position, const Glib::ustring &amp;replacement, RegexMatchFlags match_options=static_cast&lt; RegexMatchFlags &gt;(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"> <em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurrences of the pattern in <em>regex</em> with the replacement text. </p>
<p>Backreferences of the form '' or '&lt;number&gt;' in the replacement text are interpolated by the number-th captured subexpression of the match, '&lt;name&gt;' refers to the captured subexpression with the given name. '' refers to the complete match, but '' followed by a number is the octal representation of a character. To include a literal '\' in the replacement, write '\'. There are also escapes that changes the case of the following text:</p>
<p>&lt;variablelist&gt; &lt;varlistentry&gt;<b></b> &lt;listitem&gt; </p>
<p>Convert to lower case the next character</p>
<p>&lt;/listitem&gt; &lt;/varlistentry&gt; &lt;varlistentry&gt;<b></b> &lt;listitem&gt; </p>
<p>Convert to upper case the next character</p>
<p>&lt;/listitem&gt; &lt;/varlistentry&gt; &lt;varlistentry&gt;<b></b> &lt;listitem&gt; </p>
<p>Convert to lower case till </p>
<p>&lt;/listitem&gt; &lt;/varlistentry&gt; &lt;varlistentry&gt;<b></b> &lt;listitem&gt; </p>
<p>Convert to upper case till </p>
<p>&lt;/listitem&gt; &lt;/varlistentry&gt; &lt;varlistentry&gt;<b></b> &lt;listitem&gt; </p>
<p>End case modification</p>
<p>&lt;/listitem&gt; &lt;/varlistentry&gt; &lt;/variablelist&gt;</p>
<p>If you do not need to use backreferences use g_regex_replace_literal().</p>
<p>The <em>replacement</em> string must be UTF-8 encoded even if REGEX_RAW was passed to g_regex_new(). If you want to use not UTF-8 encoded stings you can use g_regex_replace_literal().</p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\b".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000022">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&#160;</td><td>The string to perform matches against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>string_len</em>&#160;</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_position</em>&#160;</td><td>Starting index of the string to match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&#160;</td><td>Text to replace each match with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_options</em>&#160;</td><td>Options for the match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly allocated string containing the replacements. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5a2cf889ebf233c5d467b3816c8d533"></a><!-- doxytag: member="Glib::Regex::replace_eval" ref="ac5a2cf889ebf233c5d467b3816c8d533" args="(const Glib::ustring &amp;string, gssize string_len, int start_position, RegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace_eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"> <em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GRegexEvalCallback&#160;</td>
          <td class="paramname"> <em>eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"> <em>user_data</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces occurrences of the pattern in regex with the output of <em>eval</em> for that occurrence. </p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\b".</p>
<p>The following example uses g_regex_replace_eval() to replace multiple strings at once: |[ static <code>bool</code> eval_cb (const GMatchInfo *info, GString *res, gpointer data) { gchar *match; gchar *r;</p>
<p>match = g_match_info_fetch (info, 0); r = g_hash_table_lookup ((GHashTable *)data, match); g_string_append (res, r); g_free (match);</p>
<p>return <code>false</code>; }</p>
<p>/ * ... * /</p>
<p>GRegex *reg; GHashTable *h; gchar *res;</p>
<p>h = g_hash_table_new (g_str_hash, g_str_equal);</p>
<p>g_hash_table_insert (h, "1", "ONE"); g_hash_table_insert (h, "2", "TWO"); g_hash_table_insert (h, "3", "THREE"); g_hash_table_insert (h, "4", "FOUR");</p>
<p>reg = g_regex_new ("1|2|3|4", 0, 0, <code>0</code>); res = g_regex_replace_eval (reg, text, -1, 0, 0, eval_cb, h, <code>0</code>); g_hash_table_destroy (h);</p>
<p>/ * ... * / ]|</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000024">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&#160;</td><td>String to perform matches against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>string_len</em>&#160;</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_position</em>&#160;</td><td>Starting index of the string to match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_options</em>&#160;</td><td>Options for the match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eval</em>&#160;</td><td>A function to call for each match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&#160;</td><td>User data to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly allocated string containing the replacements. </dd></dl>

</div>
</div>
<a class="anchor" id="a6660f8fcf2ec8a6e90a7ecc85ced0e2a"></a><!-- doxytag: member="Glib::Regex::replace_literal" ref="a6660f8fcf2ec8a6e90a7ecc85ced0e2a" args="(const Glib::ustring &amp;string, int start_position, const Glib::ustring &amp;replacement, RegexMatchFlags match_options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace_literal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4bccbbffa1c84249b35201ee6e6f39c9"></a><!-- doxytag: member="Glib::Regex::replace_literal" ref="a4bccbbffa1c84249b35201ee6e6f39c9" args="(const gchar *string, gssize string_len, int start_position, const Glib::ustring &amp;replacement, RegexMatchFlags match_options=static_cast&lt; RegexMatchFlags &gt;(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace_literal </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"> <em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurrences of the pattern in <em>regex</em> with the replacement text. </p>
<p><em>replacement</em> is replaced literally, to include backreferences use g_regex_replace().</p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\b".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000023">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&#160;</td><td>The string to perform matches against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>string_len</em>&#160;</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_position</em>&#160;</td><td>Starting index of the string to match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&#160;</td><td>Text to replace each match with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_options</em>&#160;</td><td>Options for the match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly allocated string containing the replacements. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f2f68542607519a358dd0ada1b5e3d5"></a><!-- doxytag: member="Glib::Regex::split" ref="a3f2f68542607519a358dd0ada1b5e3d5" args="(const Glib::ustring &amp;string, int start_position, RegexMatchFlags match_options, int max_tokens) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ArrayHandle.html">Glib::StringArrayHandle</a> Glib::Regex::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>max_tokens</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ace0220e0ed2d7bd7771030e360e5141f"></a><!-- doxytag: member="Glib::Regex::split" ref="ace0220e0ed2d7bd7771030e360e5141f" args="(const gchar *string, gssize string_len, int start_position, RegexMatchFlags match_options=static_cast&lt; RegexMatchFlags &gt;(0), int max_tokens=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ArrayHandle.html">Glib::StringArrayHandle</a> Glib::Regex::split </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"> <em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>max_tokens</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Breaks the string on the pattern, and returns an array of the tokens. </p>
<p>If the pattern contains capturing parentheses, then the text for each of the substrings will also be returned. If the pattern does not match anywhere in the string, then the whole string is returned as the first token.</p>
<p>As a special case, the result of splitting the empty string "" is an empty vector, not a vector containing a single string. The reason for this special case is that being able to represent a empty vector is typically more useful than consistent handling of empty elements. If you do need to represent empty elements, you'll need to check for the empty string before calling this function.</p>
<p>A pattern that can match empty strings splits <em>string</em> into separate characters wherever it matches the empty string between characters. For example splitting "ab c" using as a separator "\s*", you will get "a", "b" and "c".</p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\b".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000021">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&#160;</td><td>The string to split with the pattern. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>string_len</em>&#160;</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_position</em>&#160;</td><td>Starting index of the string to match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_options</em>&#160;</td><td>Match time option flags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_tokens</em>&#160;</td><td>The maximum number of tokens to split <em>string</em> into. If this is less than 1, the string is split completely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>0</code>-terminated gchar ** array. Free it using g_strfreev(). </dd></dl>

</div>
</div>
<a class="anchor" id="a447bbb8dc8ca457d1c1a4ab0740ced7e"></a><!-- doxytag: member="Glib::Regex::split" ref="a447bbb8dc8ca457d1c1a4ab0740ced7e" args="(const Glib::ustring &amp;string, RegexMatchFlags match_options=static_cast&lt; RegexMatchFlags &gt;(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ArrayHandle.html">Glib::StringArrayHandle</a> Glib::Regex::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Breaks the string on the pattern, and returns an array of the tokens. </p>
<p>If the pattern contains capturing parentheses, then the text for each of the substrings will also be returned. If the pattern does not match anywhere in the string, then the whole string is returned as the first token.</p>
<p>As a special case, the result of splitting the empty string "" is an empty vector, not a vector containing a single string. The reason for this special case is that being able to represent a empty vector is typically more useful than consistent handling of empty elements. If you do need to represent empty elements, you'll need to check for the empty string before calling this function.</p>
<p>A pattern that can match empty strings splits <em>string</em> into separate characters wherever it matches the empty string between characters. For example splitting "ab c" using as a separator "\s*", you will get "a", "b" and "c".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000020">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&#160;</td><td>The string to split with the pattern. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_options</em>&#160;</td><td>Match time option flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>0</code>-terminated gchar ** array. Free it using g_strfreev(). </dd></dl>

</div>
</div>
<a class="anchor" id="aa0911a410fa5295667d54e900cce7f10"></a><!-- doxytag: member="Glib::Regex::split_simple" ref="aa0911a410fa5295667d54e900cce7f10" args="(const Glib::ustring &amp;pattern, const Glib::ustring &amp;string, RegexCompileFlags compile_options=static_cast&lt; RegexCompileFlags &gt;(0), RegexMatchFlags match_options=static_cast&lt; RegexMatchFlags &gt;(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::StringArrayHandle</a> Glib::Regex::split_simple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;</td>
          <td class="paramname"> <em>compile_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"> <em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Breaks the string on the pattern, and returns an array of the tokens. </p>
<p>If the pattern contains capturing parentheses, then the text for each of the substrings will also be returned. If the pattern does not match anywhere in the string, then the whole string is returned as the first token.</p>
<p>This function is equivalent to g_regex_split() but it does not require to compile the pattern with g_regex_new(), avoiding some lines of code when you need just to do a split without extracting substrings, capture counts, and so on.</p>
<p>If this function is to be called on the same <em>pattern</em> more than once, it's more efficient to compile the pattern once with g_regex_new() and then use g_regex_split().</p>
<p>As a special case, the result of splitting the empty string "" is an empty vector, not a vector containing a single string. The reason for this special case is that being able to represent a empty vector is typically more useful than consistent handling of empty elements. If you do need to represent empty elements, you'll need to check for the empty string before calling this function.</p>
<p>A pattern that can match empty strings splits <em>string</em> into separate characters wherever it matches the empty string between characters. For example splitting "ab c" using as a separator "\s*", you will get "a", "b" and "c".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000019">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&#160;</td><td>The regular expression. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>string</em>&#160;</td><td>The string to scan for matches. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compile_options</em>&#160;</td><td>Compile options for the regular expression, or 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_options</em>&#160;</td><td>Match options, or 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>0</code>-terminated array of strings. Free it using g_strfreev(). </dd></dl>

</div>
</div>
<a class="anchor" id="a661a9b85f52dbaaa68a6495ace7df50a"></a><!-- doxytag: member="Glib::Regex::unreference" ref="a661a9b85f52dbaaa68a6495ace7df50a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Regex::unreference </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrement the reference count for this object. </p>
<p>You should never need to do this manually - use the object via a <a class="el" href="classGlib_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">RefPtr</a> instead. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aa502a39684fb9d59dc689da8bb9d9da8"></a><!-- doxytag: member="Glib::Regex::wrap" ref="aa502a39684fb9d59dc689da8bb9d9da8" args="(GRegex *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Regex.html">Glib::Regex</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GRegex *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&#160;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&#160;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Mon May 3 23:46:31 2010 for glibmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
