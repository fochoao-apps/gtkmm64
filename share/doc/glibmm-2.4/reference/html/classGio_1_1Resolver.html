<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>glibmm: Gio::Resolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1Resolver.html">Resolver</a>
  </div>
</div>
<div class="contents">
<h1>Gio::Resolver Class Reference<br/>
<small>
[<a class="el" href="group__NetworkIO.html">Portable Network I/O Functionality</a>]</small>
</h1><!-- doxytag: class="Gio::Resolver" --><!-- doxytag: inherits="Glib::Object" -->
<p>Asynchronous and cancellable DNS resolver. <a href="#_details">More...</a></p>

<p><code>#include &lt;giomm/resolver.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::Resolver:</div>
<div class="dynsection">
<div class="center"><img src="classGio_1_1Resolver__inherit__graph.png" border="0" usemap="#Gio_1_1Resolver_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1Resolver_inherit__map" id="Gio_1_1Resolver_inherit__map">
<area shape="rect" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="21,161,115,188"/><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="5,84,131,111"/><area shape="rect" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="12,7,124,33"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1Resolver-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a91fb01b808b2e2d315d9ffc149f1f71e">~Resolver</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GResolver*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a4d323772493d0cf739816c80f08398d2">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a4d323772493d0cf739816c80f08398d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GResolver*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a77d572cc0c4a48c47ec06e9a5f2d02a9">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a77d572cc0c4a48c47ec06e9a5f2d02a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GResolver*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#ae1cf170f1700985b286238d5f1dcbab2">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#ae1cf170f1700985b286238d5f1dcbab2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#aea1576fa2684d9bca58a589098a8371e">lookup_by_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; hostname, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously resolves <em>hostname</em> to determine its associated IP address(es). <a href="#aea1576fa2684d9bca58a589098a8371e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a4aaf18d0bcc67d6d139d993b140a8b14">lookup_by_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; hostname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a0130482bb442e3a006e06d57665c2318">lookup_by_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; hostname, const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#ae38a0fc714443839c0bb3a0e40dcd082">lookup_by_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; hostname, const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#afaf6f9f003fd213ebecb893d60f14380">lookup_by_name_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the result of a call to g_resolver_lookup_by_name_async(). <a href="#afaf6f9f003fd213ebecb893d60f14380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#abb5740225148191d2e93d7a6b12caf23">lookup_by_address</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously reverse-resolves <em>address</em> to determine its associated hostname. <a href="#abb5740225148191d2e93d7a6b12caf23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a81f793a31c8ddaa2bf26361721c3fd1c">lookup_by_address</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a3bfd36d312e60b748df35089d5126b4f">lookup_by_address_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; address, const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a91d05a43f8083af54826fcb3303e0eba">lookup_by_address_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; address, const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#ae127e4682bfb20ef0b292e7b98460762">lookup_by_address_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the result of a previous call to g_resolver_lookup_by_address_async(). <a href="#ae127e4682bfb20ef0b292e7b98460762"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ListHandle.html">ListHandle_SrvTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#aab5e246c4f14e55e079c8a280dd3de5b">lookup_service</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; service, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; protocol, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; domain, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously performs a DNS SRV lookup for the given <em>service</em> and <em>protocol</em> in the given <em>domain</em> and returns an array of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>. <a href="#aab5e246c4f14e55e079c8a280dd3de5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ListHandle.html">ListHandle_SrvTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a3b131a66a7a7bd3e89713384ff2f6be3">lookup_service</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; service, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; protocol, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; domain)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a49d103c02f6e0e8ad5d4e7abb1967ef0">lookup_service_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; service, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; protocol, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; domain, const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a58d46752ddd5305d811df4707c3ce4a7">lookup_service_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; service, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; protocol, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; domain, const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ListHandle.html">ListHandle_SrvTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#aae68cb39415c9286474d92c7aeba2e47">lookup_service_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the result of a previous call to g_resolver_lookup_service_async(). <a href="#aae68cb39415c9286474d92c7aeba2e47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a097abf4f88816a46fa2272430a1b5e3d">signal_reload</a> ()</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Resolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#ac822ffe60ab0ce2acfdc85ccb908f6fc">get_default</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#afbb1fb4f9edb0e553dbb61ca2437601c">set_default</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Resolver</a> &gt;&amp; resolver)</td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Gio::Resolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#aa710fc39dacfe0e34730487741d84fb9">wrap</a> (GResolver* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#aa710fc39dacfe0e34730487741d84fb9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Asynchronous and cancellable DNS resolver. </p>
<p><a class="el" href="classGio_1_1Resolver.html" title="Asynchronous and cancellable DNS resolver.">Resolver</a> provides cancellable synchronous and asynchronous DNS resolution, for hostnames (<a class="el" href="classGio_1_1Resolver.html#abb5740225148191d2e93d7a6b12caf23" title="Synchronously reverse-resolves address to determine its associated hostname.">lookup_by_address()</a>, <a class="el" href="classGio_1_1Resolver.html#aea1576fa2684d9bca58a589098a8371e" title="Synchronously resolves hostname to determine its associated IP address(es).">lookup_by_name()</a> and their async variants) and SRV (service) records (<a class="el" href="classGio_1_1Resolver.html#aab5e246c4f14e55e079c8a280dd3de5b" title="Synchronously performs a DNS SRV lookup for the given service and protocol in the...">lookup_service()</a>).</p>
<p><a class="el" href="classGio_1_1NetworkAddress.html" title="A SocketConnectable for resolving hostnames.">NetworkAddress</a> and <a class="el" href="classGio_1_1NetworkService.html" title="A GSocketConnectable for resolving SRV records.">NetworkService</a> provide wrappers around <a class="el" href="classGio_1_1Resolver.html" title="Asynchronous and cancellable DNS resolver.">Resolver</a> functionality that also implement <a class="el" href="classGio_1_1SocketConnectable.html" title="Interface for potential socket endpoints.">SocketConnectable</a>, making it easy to connect to a remote host/service.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000007">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a91fb01b808b2e2d315d9ffc149f1f71e"></a><!-- doxytag: member="Gio::Resolver::~Resolver" ref="a91fb01b808b2e2d315d9ffc149f1f71e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::Resolver::~Resolver </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac822ffe60ab0ce2acfdc85ccb908f6fc"></a><!-- doxytag: member="Gio::Resolver::get_default" ref="ac822ffe60ab0ce2acfdc85ccb908f6fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Resolver.html">Resolver</a>&gt; Gio::Resolver::get_default </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a77d572cc0c4a48c47ec06e9a5f2d02a9"></a><!-- doxytag: member="Gio::Resolver::gobj" ref="a77d572cc0c4a48c47ec06e9a5f2d02a9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GResolver* Gio::Resolver::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="a4d323772493d0cf739816c80f08398d2"></a><!-- doxytag: member="Gio::Resolver::gobj" ref="a4d323772493d0cf739816c80f08398d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GResolver* Gio::Resolver::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="ae1cf170f1700985b286238d5f1dcbab2"></a><!-- doxytag: member="Gio::Resolver::gobj_copy" ref="ae1cf170f1700985b286238d5f1dcbab2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GResolver* Gio::Resolver::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a81f793a31c8ddaa2bf26361721c3fd1c"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address" ref="a81f793a31c8ddaa2bf26361721c3fd1c" args="(const Glib::RefPtr&lt; InetAddress &gt; &amp;address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Gio::Resolver::lookup_by_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abb5740225148191d2e93d7a6b12caf23"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address" ref="abb5740225148191d2e93d7a6b12caf23" args="(const Glib::RefPtr&lt; InetAddress &gt; &amp;address, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Gio::Resolver::lookup_by_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously reverse-resolves <em>address</em> to determine its associated hostname. </p>
<p>If the DNS resolution fails, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>.</p>
<p>If <em>cancellable</em> is non-<code>0</code>, it can be used to cancel the operation, in which case <em>error</em> (if non-<code>0</code>) will be set to IO_ERROR_CANCELLED.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000076">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&#160;</td><td>The address to reverse-resolve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A hostname (either ASCII-only, or in ASCII-encoded form), or <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a91d05a43f8083af54826fcb3303e0eba"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address_async" ref="a91d05a43f8083af54826fcb3303e0eba" args="(const Glib::RefPtr&lt; InetAddress &gt; &amp;address, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Resolver::lookup_by_address_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3bfd36d312e60b748df35089d5126b4f"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address_async" ref="a3bfd36d312e60b748df35089d5126b4f" args="(const Glib::RefPtr&lt; InetAddress &gt; &amp;address, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Resolver::lookup_by_address_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae127e4682bfb20ef0b292e7b98460762"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address_finish" ref="ae127e4682bfb20ef0b292e7b98460762" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Gio::Resolver::lookup_by_address_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the result of a previous call to g_resolver_lookup_by_address_async(). </p>
<p>If the DNS resolution failed, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>. If the operation was cancelled, <em>error</em> will be set to IO_ERROR_CANCELLED.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000077">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>The result passed to your AsyncReadyCallback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A hostname (either ASCII-only, or in ASCII-encoded form), or <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4aaf18d0bcc67d6d139d993b140a8b14"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name" ref="a4aaf18d0bcc67d6d139d993b140a8b14" args="(const Glib::ustring &amp;hostname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InetAddress.html">InetAddress</a>&gt; &gt; Gio::Resolver::lookup_by_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>hostname</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea1576fa2684d9bca58a589098a8371e"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name" ref="aea1576fa2684d9bca58a589098a8371e" args="(const Glib::ustring &amp;hostname, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InetAddress.html">InetAddress</a>&gt; &gt; Gio::Resolver::lookup_by_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously resolves <em>hostname</em> to determine its associated IP address(es). </p>
<p><em>hostname</em> may be an ASCII-only or UTF-8 hostname, or the textual form of an IP address (in which case this just becomes a wrapper around g_inet_address_new_from_string()).</p>
<p>On success, g_resolver_lookup_by_name() will return a List of <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a>, sorted in order of preference. (That is, you should attempt to connect to the first address first, then the second if the first fails, etc.)</p>
<p>If the DNS resolution fails, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>.</p>
<p>If <em>cancellable</em> is non-<code>0</code>, it can be used to cancel the operation, in which case <em>error</em> (if non-<code>0</code>) will be set to IO_ERROR_CANCELLED.</p>
<p>If you are planning to connect to a socket on the resolved IP address, it may be easier to create a <a class="el" href="classGio_1_1NetworkAddress.html" title="A SocketConnectable for resolving hostnames.">NetworkAddress</a> and use its <a class="el" href="classGio_1_1SocketConnectable.html" title="Interface for potential socket endpoints.">SocketConnectable</a> interface.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000074">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hostname</em>&#160;</td><td>The hostname to look up. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A List of <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a>, or <code>0</code> on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.). </dd></dl>

</div>
</div>
<a class="anchor" id="ae38a0fc714443839c0bb3a0e40dcd082"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name_async" ref="ae38a0fc714443839c0bb3a0e40dcd082" args="(const Glib::ustring &amp;hostname, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Resolver::lookup_by_name_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0130482bb442e3a006e06d57665c2318"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name_async" ref="a0130482bb442e3a006e06d57665c2318" args="(const Glib::ustring &amp;hostname, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Resolver::lookup_by_name_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afaf6f9f003fd213ebecb893d60f14380"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name_finish" ref="afaf6f9f003fd213ebecb893d60f14380" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InetAddress.html">InetAddress</a>&gt; &gt; Gio::Resolver::lookup_by_name_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the result of a call to g_resolver_lookup_by_name_async(). </p>
<p>If the DNS resolution failed, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>. If the operation was cancelled, <em>error</em> will be set to IO_ERROR_CANCELLED.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000075">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>The result passed to your AsyncReadyCallback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A List of <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a>, or <code>0</code> on error. See g_resolver_lookup_by_name() for more details. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b131a66a7a7bd3e89713384ff2f6be3"></a><!-- doxytag: member="Gio::Resolver::lookup_service" ref="a3b131a66a7a7bd3e89713384ff2f6be3" args="(const Glib::ustring &amp;service, const Glib::ustring &amp;protocol, const Glib::ustring &amp;domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ListHandle.html">ListHandle_SrvTarget</a> Gio::Resolver::lookup_service </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>domain</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab5e246c4f14e55e079c8a280dd3de5b"></a><!-- doxytag: member="Gio::Resolver::lookup_service" ref="aab5e246c4f14e55e079c8a280dd3de5b" args="(const Glib::ustring &amp;service, const Glib::ustring &amp;protocol, const Glib::ustring &amp;domain, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ListHandle.html">ListHandle_SrvTarget</a> Gio::Resolver::lookup_service </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously performs a DNS SRV lookup for the given <em>service</em> and <em>protocol</em> in the given <em>domain</em> and returns an array of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>. </p>
<p><em>domain</em> may be an ASCII-only or UTF-8 hostname. Note also that the <em>service</em> and <em>protocol</em> arguments &lt;emphasis&gt;do not&lt;/emphasis&gt; include the leading underscore that appears in the actual DNS entry.</p>
<p>On success, g_resolver_lookup_service() will return a List of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>, sorted in order of preference. (That is, you should attempt to connect to the first target first, then the second if the first fails, etc.)</p>
<p>If the DNS resolution fails, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>.</p>
<p>If <em>cancellable</em> is non-<code>0</code>, it can be used to cancel the operation, in which case <em>error</em> (if non-<code>0</code>) will be set to IO_ERROR_CANCELLED.</p>
<p>If you are planning to connect to the service, it is usually easier to create a <a class="el" href="classGio_1_1NetworkService.html" title="A GSocketConnectable for resolving SRV records.">NetworkService</a> and use its <a class="el" href="classGio_1_1SocketConnectable.html" title="Interface for potential socket endpoints.">SocketConnectable</a> interface.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000078">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>service</em>&#160;</td><td>The service type to look up (eg, "ldap"). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&#160;</td><td>The networking protocol to use for <em>service</em> (eg, "tcp"). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&#160;</td><td>The DNS domain to look up the service in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A List of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>, or <code>0</code> on error. You must free each of the targets and the list when you are done with it. (You can use g_resolver_free_targets() to do this.). </dd></dl>

</div>
</div>
<a class="anchor" id="a58d46752ddd5305d811df4707c3ce4a7"></a><!-- doxytag: member="Gio::Resolver::lookup_service_async" ref="a58d46752ddd5305d811df4707c3ce4a7" args="(const Glib::ustring &amp;service, const Glib::ustring &amp;protocol, const Glib::ustring &amp;domain, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Resolver::lookup_service_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a49d103c02f6e0e8ad5d4e7abb1967ef0"></a><!-- doxytag: member="Gio::Resolver::lookup_service_async" ref="a49d103c02f6e0e8ad5d4e7abb1967ef0" args="(const Glib::ustring &amp;service, const Glib::ustring &amp;protocol, const Glib::ustring &amp;domain, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Resolver::lookup_service_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">SlotAsyncReady</a> &amp;&#160;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aae68cb39415c9286474d92c7aeba2e47"></a><!-- doxytag: member="Gio::Resolver::lookup_service_finish" ref="aae68cb39415c9286474d92c7aeba2e47" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ListHandle.html">ListHandle_SrvTarget</a> Gio::Resolver::lookup_service_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the result of a previous call to g_resolver_lookup_service_async(). </p>
<p>If the DNS resolution failed, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>. If the operation was cancelled, <em>error</em> will be set to IO_ERROR_CANCELLED.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000079">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&#160;</td><td>The result passed to your AsyncReadyCallback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A List of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>, or <code>0</code> on error. See g_resolver_lookup_service() for more details. </dd></dl>

</div>
</div>
<a class="anchor" id="afbb1fb4f9edb0e553dbb61ca2437601c"></a><!-- doxytag: member="Gio::Resolver::set_default" ref="afbb1fb4f9edb0e553dbb61ca2437601c" args="(const Glib::RefPtr&lt; Resolver &gt; &amp;resolver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gio::Resolver::set_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Resolver</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>resolver</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a097abf4f88816a46fa2272430a1b5e3d"></a><!-- doxytag: member="Gio::Resolver::signal_reload" ref="a097abf4f88816a46fa2272430a1b5e3d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt; Gio::Resolver::signal_reload </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Prototype:</b></dt><dd><code>void on_my_reload()</code> </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aa710fc39dacfe0e34730487741d84fb9"></a><!-- doxytag: member="Gio::Resolver::wrap" ref="aa710fc39dacfe0e34730487741d84fb9" args="(GResolver *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Gio::Resolver</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GResolver *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&#160;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&#160;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Mon May 3 23:46:29 2010 for glibmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
