<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>glibmm: Gio::Socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1Socket.html">Socket</a>
  </div>
</div>
<div class="contents">
<h1>Gio::Socket Class Reference<br/>
<small>
[<a class="el" href="group__NetworkIO.html">Portable Network I/O Functionality</a>]</small>
</h1><!-- doxytag: class="Gio::Socket" --><!-- doxytag: inherits="Glib::Object,Gio::Initable" -->
<p>Low-level socket object. <a href="#_details">More...</a></p>

<p><code>#include &lt;giomm/socket.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::Socket:</div>
<div class="dynsection">
<div class="center"><img src="classGio_1_1Socket__inherit__graph.png" border="0" usemap="#Gio_1_1Socket_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1Socket_inherit__map" id="Gio_1_1Socket_inherit__map">
<area shape="rect" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="5,239,99,265"/><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="41,84,167,111"/><area shape="rect" href="classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="109,161,219,188"/><area shape="rect" href="file:///C:/msys/win64/gtkmm_debug/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="48,7,160,33"/><area shape="rect" href="classGio_1_1Initable.html" title="Failable object initialization interface." alt="" coords="123,239,219,265"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1Socket-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8efac59d8562ceb635b76fe70087572d">~Socket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GSocket*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a1d51f7bcd83450331d7261898e9007d6">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a1d51f7bcd83450331d7261898e9007d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GSocket*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a51c7fa832ce1c984a7bbceb4d7ba93a8">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a51c7fa832ce1c984a7bbceb4d7ba93a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GSocket*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae2fe06b1a579c40b596933da0ded4e37">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#ae2fe06b1a579c40b596933da0ded4e37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a16044bba5924c183cff90f0a4cf47394">bind</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, bool allow_reuse)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When a socket is created it is attached to an address family, but it doesn't have an address in this family. <a href="#a16044bba5924c183cff90f0a4cf47394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af16eed3fd42f3769b5e608f96db214fd">listen</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the socket as a server socket, i.e. a socket that is used to accept incoming requests using g_socket_accept(). <a href="#af16eed3fd42f3769b5e608f96db214fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a137ae34a8f211eaed11f9a58ca6b3f5e">accept</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept incoming connections on a connection-based socket. <a href="#a137ae34a8f211eaed11f9a58ca6b3f5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888">accept</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23">connect</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified remote address. <a href="#a9ab220f5714a6116d35e846b00f4ad23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0828763fe472d46aed833fad30af1c0b">connect</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a06b68dc0948e6dfa158487c314f9a521">check_connect_result</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and resets the pending connect error for the socket. <a href="#a06b68dc0948e6dfa158487c314f9a521"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c">receive</a> (char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01154.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data (up to <em>size</em> bytes) from a socket. <a href="#a742403f4d076ba9050a435d95fea5d1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a73463b7677ffdfddaced49bdf170b4b6">receive</a> (char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01154.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4d2d4382139553881ae139920e8db93e">receive_from</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01154.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a056fd2c3609971d5befcf2b4ccf51aa3">receive_from</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01154.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c">send</a> (const gchar* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01154.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to send <em>size</em> bytes from <em>buffer</em> on the socket. <a href="#adc5c3145109841e0406150ad0b7f547c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a986efa2a33528ce5aba0d7c6a7be1b65">send</a> (const gchar* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01154.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729">send_to</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01154.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to send <em>size</em> bytes from <em>buffer</em> to <em>address</em>. <a href="#a8b2d4ff883535e696b6cdaacd730f729"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a929c8c4e0c10a39d65358853e94d9c4f">send_to</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01154.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aab30d39b9e73fef6401c76d1d4edc118">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the socket, shutting down any active connection. <a href="#aab30d39b9e73fef6401c76d1d4edc118"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a7ac925f7e6592ad4a96afe0f75411a96">is_closed</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a socket is closed. <a href="#a7ac925f7e6592ad4a96afe0f75411a96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4f685bc040e9e10abe093deec0719fd7">shutdown</a> (bool shutdown_read, bool shutdown_write)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down part of a full-duplex connection. <a href="#a4f685bc040e9e10abe093deec0719fd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aea9561511b77e652271705fbfdb2f8f2">is_connected</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the socket is connected. <a href="#aea9561511b77e652271705fbfdb2f8f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MainLoop.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec">condition_check</a> (<a class="el" href="group__MainLoop.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks on the readiness of <em>socket</em> to perform operations. <a href="#a86fdc5d814fd61abab15ec03c7da20ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36">condition_wait</a> (<a class="el" href="group__MainLoop.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for <em>condition</em> to become true on <em>socket</em>. <a href="#aaae28fa63035c05396064f5f4bb4fc36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9ae420715a2050cc09112f178bae88ba">condition_wait</a> (<a class="el" href="group__MainLoop.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adc7b9d6cecc1c2234f9979b2ffb1b309">set_listen_backlog</a> (int backlog)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of outstanding connections allowed when listening on this socket. <a href="#adc7b9d6cecc1c2234f9979b2ffb1b309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a22a9e70db9abc7fc6383641afde8ee6f">get_listen_backlog</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the listen backlog setting of the socket. <a href="#a22a9e70db9abc7fc6383641afde8ee6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a51d5a174441c255b69be9e809cdb96b3">set_blocking</a> (bool blocking)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the blocking mode of the socket. <a href="#a51d5a174441c255b69be9e809cdb96b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a1ffcbc226b08ae14856ea0dfe4d580e9">get_blocking</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blocking mode of the socket. <a href="#a1ffcbc226b08ae14856ea0dfe4d580e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a6cfac67927584ae7afe53006eebb06d7">set_keepalive</a> (bool keepalive)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or unsets the So::KEEPALIVE flag on the underlying socket. <a href="#a6cfac67927584ae7afe53006eebb06d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a530b4adc3d295f7c000981286dee8019">get_keepalive</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the keepalive mode of the socket. <a href="#a530b4adc3d295f7c000981286dee8019"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aac1e2a576e62d1e339eefae1fe12e24b">get_family</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket family of the socket. <a href="#aac1e2a576e62d1e339eefae1fe12e24b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af3bb5076efcb022e31db9622a1c6e0ae">get_fd</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying OS socket object. <a href="#af3bb5076efcb022e31db9622a1c6e0ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a654e36f8577b61a4df93a0a70479a7f1">get_local_address</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the local address of a bound socket. <a href="#a654e36f8577b61a4df93a0a70479a7f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adce45788b8ac674bdf32a3ec8fb683c1">get_remote_address</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the remove address of a connected socket. <a href="#adce45788b8ac674bdf32a3ec8fb683c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4ecd966ee71eb956258b289cf63eb43e">get_protocol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket protocol id the socket was created with. <a href="#a4ecd966ee71eb956258b289cf63eb43e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a05cd563d5bc68362f3a574054ce63481">get_socket_type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket type of the socket. <a href="#a05cd563d5bc68362f3a574054ce63481"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae33e646694bf6c5062683ba4b79d4fe1">speaks_ipv4</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a socket is capable of speaking IPv4. <a href="#ae33e646694bf6c5062683ba4b79d4fe1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae6c0fdc10c1dd971bd75241dc8e3edaf">property_blocking</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not I/O on this socket is blocking. <a href="#ae6c0fdc10c1dd971bd75241dc8e3edaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a004c9014634a2d15bf72bde26d0946d9">property_blocking</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not I/O on this socket is blocking. <a href="#a004c9014634a2d15bf72bde26d0946d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9644d9441f3c4217c5f4f59b8821d966">property_family</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets address family. <a href="#a9644d9441f3c4217c5f4f59b8821d966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aad681d273768f49f75fbee70abaa97f2">property_fd</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets file descriptor. <a href="#aad681d273768f49f75fbee70abaa97f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a2dc3436d7a9a94b4355fef411659845e">property_keepalive</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep connection alive by sending periodic pings. <a href="#a2dc3436d7a9a94b4355fef411659845e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a86d147686d1bc91bc1350ed522ce04eb">property_keepalive</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep connection alive by sending periodic pings. <a href="#a86d147686d1bc91bc1350ed522ce04eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a013fbb1ab58b01f7f7457a1069ab5f4f">property_listen_backlog</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Outstanding connections in the listen queue. <a href="#a013fbb1ab58b01f7f7457a1069ab5f4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a24c7c56d57439271b9817ae13447550e">property_listen_backlog</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Outstanding connections in the listen queue. <a href="#a24c7c56d57439271b9817ae13447550e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ac52bc9e13993758922ce0d3683f336af">property_local_address</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The local address the socket is bound to. <a href="#ac52bc9e13993758922ce0d3683f336af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0affc1f63146a265a1d1c2b884091708">property_remote_address</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The remote address the socket is connected to. <a href="#a0affc1f63146a265a1d1c2b884091708"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a5b8ba56215c4f828d0db182c72ee5c1f">property_protocol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The id of the protocol to use. <a href="#a5b8ba56215c4f828d0db182c72ee5c1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a43cc07ec00548b77642200014a160400">property_type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets type. <a href="#a43cc07ec00548b77642200014a160400"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aad87b57121a04302e4d9b41c322f59ca">create</a> (<a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> family, <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> type, <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> protocol, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> with the defined family, type and protocol. <a href="#aad87b57121a04302e4d9b41c322f59ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8d0268c13028a8e3eeb551ca14b83b8e">create_from_fd</a> (int fd, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> from a native file descriptor or winsock SOCKET handle. <a href="#a8d0268c13028a8e3eeb551ca14b83b8e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9d2455e8d617dc7a828480d65db7b473">Socket</a> (<a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> family, <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> type, <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> protocol, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a74d7c4338fcf53743f23926fccc8c6d6">Socket</a> (int fd, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Gio::Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4b4f2145105f84580f0a2659a9e8e5db">wrap</a> (GSocket* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#a4b4f2145105f84580f0a2659a9e8e5db"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Low-level socket object. </p>
<p>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> is a low-level networking primitive. It is a more or less direct mapping of the BSD socket API in a portable GObject based API. It supports both the UNIX socket implementations and winsock2 on Windows.</p>
<p><a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> is the platform independent base upon which the higher level network primitives are based. Applications are not typically meant to use it directly, but rather through classes like <a class="el" href="classGio_1_1SocketClient.html" title="Helper for connecting to a network service.">SocketClient</a>, <a class="el" href="classGio_1_1SocketService.html" title="Make it easy to implement a network service.">SocketService</a> and <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>. However there may be cases where direct use of <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> is useful.</p>
<p><a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> implements the <a class="el" href="classGio_1_1Initable.html" title="Failable object initialization interface.">Initable</a> interface, and since initialization can fail, the constructor may throw an exception.</p>
<p>Sockets operate in two general modes, blocking or non-blocking. When in blocking mode all operations block until the requested operation is finished or there is an error. In non-blocking mode all calls that would block return immediately with a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4041bd40a7ec2e6dc8dae84c30065fec">Gio::Error::WOULD_BLOCK</a> error. To know when a call would successfully run you can call <a class="el" href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec" title="Checks on the readiness of socket to perform operations.">condition_check()</a>, or <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36" title="Waits for condition to become true on socket.">condition_wait()</a>. You can also use create_source() and attach it to a <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">Glib::MainContext</a> to get callbacks when I/O is possible. Note that all sockets are always set to non blocking mode in the system, and blocking mode is emulated in <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>.</p>
<p>When working in non-blocking mode applications should always be able to handle getting a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4041bd40a7ec2e6dc8dae84c30065fec">Gio::Error::WOULD_BLOCK</a> error even when some other function said that I/O was possible. This can easily happen in case of a race condition in the application, but it can also happen for other reasons. For instance, on Windows a socket is always seen as writable until a write returns <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4041bd40a7ec2e6dc8dae84c30065fec">Gio::Error::WOULD_BLOCK</a>.</p>
<p>Sockets can be either connection oriented or datagram based. For connection oriented types you must first establish a connection by either connecting to an address or accepting a connection from another address. For connectionless socket types the target/source address is specified or received in each I/O operation.</p>
<p>All socket file descriptors are set to be close-on-exec.</p>
<p>Note that creating a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> causes the signal SIGPIPE to be ignored for the remainder of the program. If you are writing a command-line utility that uses <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, you may need to take into account the fact that your program will not automatically be killed if it tries to write to stdout after it has been closed.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000008">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8efac59d8562ceb635b76fe70087572d"></a><!-- doxytag: member="Gio::Socket::~Socket" ref="a8efac59d8562ceb635b76fe70087572d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::Socket::~Socket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d2455e8d617dc7a828480d65db7b473"></a><!-- doxytag: member="Gio::Socket::Socket" ref="a9d2455e8d617dc7a828480d65db7b473" args="(SocketFamily family, SocketType type, SocketProtocol protocol, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gio::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&#160;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74d7c4338fcf53743f23926fccc8c6d6"></a><!-- doxytag: member="Gio::Socket::Socket" ref="a74d7c4338fcf53743f23926fccc8c6d6" args="(int fd, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gio::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4b6c036db4e484e6b7f0419962254888"></a><!-- doxytag: member="Gio::Socket::accept" ref="a4b6c036db4e484e6b7f0419962254888" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::accept </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a137ae34a8f211eaed11f9a58ca6b3f5e"></a><!-- doxytag: member="Gio::Socket::accept" ref="a137ae34a8f211eaed11f9a58ca6b3f5e" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::accept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept incoming connections on a connection-based socket. </p>
<p>This removes the first outstanding connection request from the listening socket and creates a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> object for it.</p>
<p>The <em>socket</em> must be bound to a local address with g_socket_bind() and must be listening for incoming connections (g_socket_listen()).</p>
<p>If there are no outstanding connections then the operation will block or return IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be notified of an incoming connection, wait for the IO_IN condition.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000084">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a16044bba5924c183cff90f0a4cf47394"></a><!-- doxytag: member="Gio::Socket::bind" ref="a16044bba5924c183cff90f0a4cf47394" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, bool allow_reuse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>allow_reuse</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When a socket is created it is attached to an address family, but it doesn't have an address in this family. </p>
<p>g_socket_bind() assigns the address (sometimes called name) of the socket.</p>
<p>It is generally required to bind to a local address before you can receive connections. (See g_socket_listen() and g_socket_accept() ). In certain situations, you may also want to bind a socket that will be used to initiate connections, though this is not normally required.</p>
<p><em>allow_reuse</em> should be <code>true</code> for server sockets (sockets that you will eventually call g_socket_accept() on), and <code>false</code> for client sockets. (Specifically, if it is <code>true</code>, then g_socket_bind() will set the So::REUSEADDR flag on the socket, allowing it to bind <em>address</em> even if that address was previously used by another socket that has not yet been fully cleaned-up by the kernel. Failing to set this flag on a server socket may cause the bind call to return IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then immediately restarted.)</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000082">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&#160;</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> specifying the local address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allow_reuse</em>&#160;</td><td>Whether to allow reusing this address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a06b68dc0948e6dfa158487c314f9a521"></a><!-- doxytag: member="Gio::Socket::check_connect_result" ref="a06b68dc0948e6dfa158487c314f9a521" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::check_connect_result </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks and resets the pending connect error for the socket. </p>
<p>This is used to check for errors when g_socket_connect() is used in non-blocking mode.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000086">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if no error, <code>false</code> otherwise, setting <em>error</em> to the error. </dd></dl>

</div>
</div>
<a class="anchor" id="aab30d39b9e73fef6401c76d1d4edc118"></a><!-- doxytag: member="Gio::Socket::close" ref="aab30d39b9e73fef6401c76d1d4edc118" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the socket, shutting down any active connection. </p>
<p>Closing a socket does not wait for all outstanding I/O operations to finish, so the caller should not rely on them to be guaranteed to complete even if the close returns with no error.</p>
<p>Once the socket is closed, all other operations will return IO_ERROR_CLOSED. Closing a socket multiple times will not return an error.</p>
<p>Sockets will be automatically closed when the last reference is dropped, but you might want to call this function to make sure resources are released as early as possible.</p>
<p>Beware that due to the way that TCP works, it is possible for recently-sent data to be lost if either you close a socket while the IO_IN condition is set, or else if the remote connection tries to send something to you after you close the socket but before it has finished reading all of the data you sent. There is no easy generic way to avoid this problem; the easiest fix is to design the network protocol such that the client will never send data "out of turn". Another solution is for the server to half-close the connection by calling g_socket_shutdown() with only the <em>shutdown_write</em> flag set, and then wait for the client to notice this and close its side of the connection, after which the server can safely call g_socket_close(). (This is what <a class="el" href="classGio_1_1TcpConnection.html" title="A TCP SocketConnection.">TcpConnection</a> does if you call g_tcp_connection_set_graceful_disconnect(). But of course, this only works if the client will close its connection after the server does.)</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000090">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a86fdc5d814fd61abab15ec03c7da20ec"></a><!-- doxytag: member="Gio::Socket::condition_check" ref="a86fdc5d814fd61abab15ec03c7da20ec" args="(Glib::IOCondition condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MainLoop.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> Gio::Socket::condition_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MainLoop.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"> <em>condition</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks on the readiness of <em>socket</em> to perform operations. </p>
<p>The operations specified in <em>condition</em> are checked for and masked against the currently-satisfied conditions on <em>socket</em>. The result is returned.</p>
<p>It is meaningless to specify IO_ERR or IO_HUP in condition; these conditions will always be set in the output if they are true.</p>
<p>This call never blocks.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000094">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&#160;</td><td>A IOCondition mask to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <em>GIOCondition</em> mask of the current state. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ae420715a2050cc09112f178bae88ba"></a><!-- doxytag: member="Gio::Socket::condition_wait" ref="a9ae420715a2050cc09112f178bae88ba" args="(Glib::IOCondition condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::condition_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MainLoop.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"> <em>condition</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaae28fa63035c05396064f5f4bb4fc36"></a><!-- doxytag: member="Gio::Socket::condition_wait" ref="aaae28fa63035c05396064f5f4bb4fc36" args="(Glib::IOCondition condition, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::condition_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MainLoop.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"> <em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for <em>condition</em> to become true on <em>socket</em>. </p>
<p>When the condition is met, <code>true</code> is returned.</p>
<p>If <em>cancellable</em> is cancelled before the condition is met then <code>false</code> is returned and <em>error</em>, if non-<code>0</code>, is set to IO_ERROR_CANCELLED.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000095">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&#160;</td><td>A IOCondition mask to wait for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the condition was met, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0828763fe472d46aed833fad30af1c0b"></a><!-- doxytag: member="Gio::Socket::connect" ref="a0828763fe472d46aed833fad30af1c0b" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ab220f5714a6116d35e846b00f4ad23"></a><!-- doxytag: member="Gio::Socket::connect" ref="a9ab220f5714a6116d35e846b00f4ad23" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect the socket to the specified remote address. </p>
<p>For connection oriented socket this generally means we attempt to make a connection to the <em>address</em>. For a connection-less socket it sets the default address for g_socket_send() and discards all incoming datagrams from other sources.</p>
<p>Generally connection oriented sockets can only connect once, but connection-less sockets can connect multiple times to change the default address.</p>
<p>If the connect call needs to do network I/O it will block, unless non-blocking I/O is enabled. Then IO_ERROR_PENDING is returned and the user can be notified of the connection finishing by waiting for the G_IO_OUT condition. The result of the connection can then be checked with g_socket_check_connect_result().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000085">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&#160;</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> specifying the remote address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if connected, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="aad87b57121a04302e4d9b41c322f59ca"></a><!-- doxytag: member="Gio::Socket::create" ref="aad87b57121a04302e4d9b41c322f59ca" args="(SocketFamily family, SocketType type, SocketProtocol protocol, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable=Glib::RefPtr&lt; Cancellable &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&#160;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> with the defined family, type and protocol. </p>
<p>If <em>protocol</em> is 0 (SOCKET_PROTOCOL_DEFAULT) the default protocol type for the family and type is used.</p>
<p>The <em>protocol</em> is a family and type specific int that specifies what kind of protocol to use. SocketProtocol lists several common ones. Many families only support one protocol, and use 0 for this, others support several and using 0 means to use the default protocol for the family and type.</p>
<p>The protocol id is passed directly to the operating system, so you can use protocols not listed in SocketProtocol if you know the protocol number used for it.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000080">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>family</em>&#160;</td><td>The socket family to use, e.g. SOCKET_FAMILY_IPV4. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&#160;</td><td>The socket type to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&#160;</td><td>The id of the protocol to use, or 0 for default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> or <code>0</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></em>&#160;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d0268c13028a8e3eeb551ca14b83b8e"></a><!-- doxytag: member="Gio::Socket::create_from_fd" ref="a8d0268c13028a8e3eeb551ca14b83b8e" args="(int fd, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable=Glib::RefPtr&lt; Cancellable &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::create_from_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> from a native file descriptor or winsock SOCKET handle. </p>
<p>This reads all the settings from the file descriptor so that all properties should work. Note that the file descriptor will be set to non-blocking mode, independent on the blocking mode of the <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000081">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&#160;</td><td>A native socket file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> or <code>0</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></em>&#160;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ffcbc226b08ae14856ea0dfe4d580e9"></a><!-- doxytag: member="Gio::Socket::get_blocking" ref="a1ffcbc226b08ae14856ea0dfe4d580e9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::get_blocking </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the blocking mode of the socket. </p>
<p>For details on blocking I/O, see g_socket_set_blocking().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000099">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if blocking I/O is used, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aac1e2a576e62d1e339eefae1fe12e24b"></a><!-- doxytag: member="Gio::Socket::get_family" ref="aac1e2a576e62d1e339eefae1fe12e24b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> Gio::Socket::get_family </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the socket family of the socket. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000102">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A SocketFamily. </dd></dl>

</div>
</div>
<a class="anchor" id="af3bb5076efcb022e31db9622a1c6e0ae"></a><!-- doxytag: member="Gio::Socket::get_fd" ref="af3bb5076efcb022e31db9622a1c6e0ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gio::Socket::get_fd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the underlying OS socket object. </p>
<p>On unix this is a socket file descriptor, and on windows this is a Winsock2 SOCKET handle. This may be useful for doing platform specific or otherwise unusual operations on the socket.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000103">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The file descriptor of the socket. </dd></dl>

</div>
</div>
<a class="anchor" id="a530b4adc3d295f7c000981286dee8019"></a><!-- doxytag: member="Gio::Socket::get_keepalive" ref="a530b4adc3d295f7c000981286dee8019" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::get_keepalive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the keepalive mode of the socket. </p>
<p>For details on this, see g_socket_set_keepalive().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000101">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if keepalive is active, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a22a9e70db9abc7fc6383641afde8ee6f"></a><!-- doxytag: member="Gio::Socket::get_listen_backlog" ref="a22a9e70db9abc7fc6383641afde8ee6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gio::Socket::get_listen_backlog </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the listen backlog setting of the socket. </p>
<p>For details on this, see g_socket_set_listen_backlog().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000097">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum number of pending connections. </dd></dl>

</div>
</div>
<a class="anchor" id="a654e36f8577b61a4df93a0a70479a7f1"></a><!-- doxytag: member="Gio::Socket::get_local_address" ref="a654e36f8577b61a4df93a0a70479a7f1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; Gio::Socket::get_local_address </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to get the local address of a bound socket. </p>
<p>This is only useful if the socket has been bound to a local address, either explicitly or implicitly when connecting.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000104">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4ecd966ee71eb956258b289cf63eb43e"></a><!-- doxytag: member="Gio::Socket::get_protocol" ref="a4ecd966ee71eb956258b289cf63eb43e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> Gio::Socket::get_protocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the socket protocol id the socket was created with. </p>
<p>In case the protocol is unknown, -1 is returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000106">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A protocol id, or -1 if unknown. </dd></dl>

</div>
</div>
<a class="anchor" id="adce45788b8ac674bdf32a3ec8fb683c1"></a><!-- doxytag: member="Gio::Socket::get_remote_address" ref="adce45788b8ac674bdf32a3ec8fb683c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; Gio::Socket::get_remote_address </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to get the remove address of a connected socket. </p>
<p>This is only useful for connection oriented sockets that have been connected.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000105">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a05cd563d5bc68362f3a574054ce63481"></a><!-- doxytag: member="Gio::Socket::get_socket_type" ref="a05cd563d5bc68362f3a574054ce63481" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> Gio::Socket::get_socket_type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the socket type of the socket. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000107">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A SocketType. </dd></dl>

</div>
</div>
<a class="anchor" id="a51c7fa832ce1c984a7bbceb4d7ba93a8"></a><!-- doxytag: member="Gio::Socket::gobj" ref="a51c7fa832ce1c984a7bbceb4d7ba93a8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GSocket* Gio::Socket::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1Initable.html#a30665fda96b812e27231ec5abc47b789">Gio::Initable</a>.</p>

</div>
</div>
<a class="anchor" id="a1d51f7bcd83450331d7261898e9007d6"></a><!-- doxytag: member="Gio::Socket::gobj" ref="a1d51f7bcd83450331d7261898e9007d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSocket* Gio::Socket::gobj </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1Initable.html#a90206d58591c674e03c5de57623bac18">Gio::Initable</a>.</p>

</div>
</div>
<a class="anchor" id="ae2fe06b1a579c40b596933da0ded4e37"></a><!-- doxytag: member="Gio::Socket::gobj_copy" ref="ae2fe06b1a579c40b596933da0ded4e37" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSocket* Gio::Socket::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a7ac925f7e6592ad4a96afe0f75411a96"></a><!-- doxytag: member="Gio::Socket::is_closed" ref="a7ac925f7e6592ad4a96afe0f75411a96" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::is_closed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a socket is closed. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000091">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if socket is closed, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aea9561511b77e652271705fbfdb2f8f2"></a><!-- doxytag: member="Gio::Socket::is_connected" ref="aea9561511b77e652271705fbfdb2f8f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::is_connected </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the socket is connected. </p>
<p>This is only useful for connection-oriented sockets.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000093">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if socket is connected, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af16eed3fd42f3769b5e608f96db214fd"></a><!-- doxytag: member="Gio::Socket::listen" ref="af16eed3fd42f3769b5e608f96db214fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::listen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the socket as a server socket, i.e. a socket that is used to accept incoming requests using g_socket_accept(). </p>
<p>Before calling this the socket must be bound to a local address using g_socket_bind().</p>
<p>To set the maximum amount of outstanding clients, use g_socket_set_listen_backlog().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000083">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a004c9014634a2d15bf72bde26d0946d9"></a><!-- doxytag: member="Gio::Socket::property_blocking" ref="a004c9014634a2d15bf72bde26d0946d9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt;bool&gt; Gio::Socket::property_blocking </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether or not I/O on this socket is blocking. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6c0fdc10c1dd971bd75241dc8e3edaf"></a><!-- doxytag: member="Gio::Socket::property_blocking" ref="ae6c0fdc10c1dd971bd75241dc8e3edaf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt;bool&gt; Gio::Socket::property_blocking </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether or not I/O on this socket is blocking. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a9644d9441f3c4217c5f4f59b8821d966"></a><!-- doxytag: member="Gio::Socket::property_family" ref="a9644d9441f3c4217c5f4f59b8821d966" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt;<a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&gt; Gio::Socket::property_family </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sockets address family. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aad681d273768f49f75fbee70abaa97f2"></a><!-- doxytag: member="Gio::Socket::property_fd" ref="aad681d273768f49f75fbee70abaa97f2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt;int&gt; Gio::Socket::property_fd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sockets file descriptor. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a86d147686d1bc91bc1350ed522ce04eb"></a><!-- doxytag: member="Gio::Socket::property_keepalive" ref="a86d147686d1bc91bc1350ed522ce04eb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt;bool&gt; Gio::Socket::property_keepalive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep connection alive by sending periodic pings. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dc3436d7a9a94b4355fef411659845e"></a><!-- doxytag: member="Gio::Socket::property_keepalive" ref="a2dc3436d7a9a94b4355fef411659845e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt;bool&gt; Gio::Socket::property_keepalive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep connection alive by sending periodic pings. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a24c7c56d57439271b9817ae13447550e"></a><!-- doxytag: member="Gio::Socket::property_listen_backlog" ref="a24c7c56d57439271b9817ae13447550e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt;int&gt; Gio::Socket::property_listen_backlog </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Outstanding connections in the listen queue. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a013fbb1ab58b01f7f7457a1069ab5f4f"></a><!-- doxytag: member="Gio::Socket::property_listen_backlog" ref="a013fbb1ab58b01f7f7457a1069ab5f4f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt;int&gt; Gio::Socket::property_listen_backlog </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Outstanding connections in the listen queue. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ac52bc9e13993758922ce0d3683f336af"></a><!-- doxytag: member="Gio::Socket::property_local_address" ref="ac52bc9e13993758922ce0d3683f336af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; &gt; Gio::Socket::property_local_address </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The local address the socket is bound to. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b8ba56215c4f828d0db182c72ee5c1f"></a><!-- doxytag: member="Gio::Socket::property_protocol" ref="a5b8ba56215c4f828d0db182c72ee5c1f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt;<a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&gt; Gio::Socket::property_protocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The id of the protocol to use. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0affc1f63146a265a1d1c2b884091708"></a><!-- doxytag: member="Gio::Socket::property_remote_address" ref="a0affc1f63146a265a1d1c2b884091708" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; &gt; Gio::Socket::property_remote_address </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The remote address the socket is connected to. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a43cc07ec00548b77642200014a160400"></a><!-- doxytag: member="Gio::Socket::property_type" ref="a43cc07ec00548b77642200014a160400" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt;<a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&gt; Gio::Socket::property_type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sockets type. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a73463b7677ffdfddaced49bdf170b4b6"></a><!-- doxytag: member="Gio::Socket::receive" ref="a73463b7677ffdfddaced49bdf170b4b6" args="(char *buffer, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>size</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a742403f4d076ba9050a435d95fea5d1c"></a><!-- doxytag: member="Gio::Socket::receive" ref="a742403f4d076ba9050a435d95fea5d1c" args="(char *buffer, gsize size, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data (up to <em>size</em> bytes) from a socket. </p>
<p>This is mainly used by connection-oriented sockets; it is identical to g_socket_receive_from() with <em>address</em> set to <code>0</code>.</p>
<p>For SOCKET_TYPE_DATAGRAM and SOCKET_TYPE_SEQPACKET sockets, g_socket_receive() will always read either 0 or 1 complete messages from the socket. If the received message is too large to fit in <em>buffer</em>, then the data beyond <em>size</em> bytes will be discarded, without any explicit indication that this has occurred.</p>
<p>For SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any number of bytes, up to <em>size</em>. If more than <em>size</em> bytes have been received, the additional data will be returned in future calls to g_socket_receive().</p>
<p>If the socket is in blocking mode the call will block until there is some data to receive or there is an error. If there is no data available and the socket is in non-blocking mode, a IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data is available, wait for the IO_IN condition.</p>
<p>On error -1 is returned and <em>error</em> is set accordingly.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000087">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&#160;</td><td>A buffer to read data into (which should be at least <em>size</em> bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&#160;</td><td>The number of bytes you want to read from the socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes read, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a056fd2c3609971d5befcf2b4ccf51aa3"></a><!-- doxytag: member="Gio::Socket::receive_from" ref="a056fd2c3609971d5befcf2b4ccf51aa3" args="(Glib::RefPtr&lt; SocketAddress &gt; &amp;address, char *buffer, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::receive_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>size</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d2d4382139553881ae139920e8db93e"></a><!-- doxytag: member="Gio::Socket::receive_from" ref="a4d2d4382139553881ae139920e8db93e" args="(Glib::RefPtr&lt; SocketAddress &gt; &amp;address, char *buffer, gsize size, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::receive_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a986efa2a33528ce5aba0d7c6a7be1b65"></a><!-- doxytag: member="Gio::Socket::send" ref="a986efa2a33528ce5aba0d7c6a7be1b65" args="(const gchar *buffer, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::send </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>size</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adc5c3145109841e0406150ad0b7f547c"></a><!-- doxytag: member="Gio::Socket::send" ref="adc5c3145109841e0406150ad0b7f547c" args="(const gchar *buffer, gsize size, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::send </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to send <em>size</em> bytes from <em>buffer</em> on the socket. </p>
<p>This is mainly used by connection-oriented sockets; it is identical to g_socket_send_to() with <em>address</em> set to <code>0</code>.</p>
<p>If the socket is in blocking mode the call will block until there is space for the data in the socket queue. If there is no space available and the socket is in non-blocking mode a IO_ERROR_WOULD_BLOCK error will be returned. To be notified when space is available, wait for the IO_OUT condition. Note though that you may still receive IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously notified of a IO_OUT condition. (On Windows in particular, this is very common due to the way the underlying APIs work.)</p>
<p>On error -1 is returned and <em>error</em> is set accordingly.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000088">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&#160;</td><td>The buffer containing the data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&#160;</td><td>The number of bytes to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a929c8c4e0c10a39d65358853e94d9c4f"></a><!-- doxytag: member="Gio::Socket::send_to" ref="a929c8c4e0c10a39d65358853e94d9c4f" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, const char *buffer, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::send_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>size</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b2d4ff883535e696b6cdaacd730f729"></a><!-- doxytag: member="Gio::Socket::send_to" ref="a8b2d4ff883535e696b6cdaacd730f729" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, const char *buffer, gsize size, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::send_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to send <em>size</em> bytes from <em>buffer</em> to <em>address</em>. </p>
<p>If <em>address</em> is <code>0</code> then the message is sent to the default receiver (set by g_socket_connect()).</p>
<p>See g_socket_send() for additional information.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000089">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&#160;</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a>, or <code>0</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&#160;</td><td>The buffer containing the data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&#160;</td><td>The number of bytes to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&#160;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a51d5a174441c255b69be9e809cdb96b3"></a><!-- doxytag: member="Gio::Socket::set_blocking" ref="a51d5a174441c255b69be9e809cdb96b3" args="(bool blocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>blocking</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the blocking mode of the socket. </p>
<p>In blocking mode all operations block until they succeed or there is an error. In non-blocking mode all functions return results immediately or with a IO_ERROR_WOULD_BLOCK error.</p>
<p>All sockets are created in blocking mode. However, note that the platform level socket is always non-blocking, and blocking mode is a GSocket level feature.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000098">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blocking</em>&#160;</td><td>Whether to use blocking I/O or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cfac67927584ae7afe53006eebb06d7"></a><!-- doxytag: member="Gio::Socket::set_keepalive" ref="a6cfac67927584ae7afe53006eebb06d7" args="(bool keepalive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_keepalive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>keepalive</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets or unsets the So::KEEPALIVE flag on the underlying socket. </p>
<p>When this flag is set on a socket, the system will attempt to verify that the remote socket endpoint is still present if a sufficiently long period of time passes with no data being exchanged. If the system is unable to verify the presence of the remote endpoint, it will automatically close the connection.</p>
<p>This option is only functional on certain kinds of sockets. (Notably, SOCKET_PROTOCOL_TCP sockets.)</p>
<p>The exact time between pings is system- and protocol-dependent, but will normally be at least two hours. Most commonly, you would set this flag on a server socket if you want to allow clients to remain idle for long periods of time, but also want to ensure that connections are eventually garbage-collected if clients crash or become unreachable.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000100">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keepalive</em>&#160;</td><td>Value for the keepalive flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc7b9d6cecc1c2234f9979b2ffb1b309"></a><!-- doxytag: member="Gio::Socket::set_listen_backlog" ref="adc7b9d6cecc1c2234f9979b2ffb1b309" args="(int backlog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_listen_backlog </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>backlog</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the maximum number of outstanding connections allowed when listening on this socket. </p>
<p>If more clients than this are connecting to the socket and the application is not handling them on time then the new connections will be refused.</p>
<p>Note that this must be called before g_socket_listen() and has no effect if called after that.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000096">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>backlog</em>&#160;</td><td>The maximum number of pending connections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f685bc040e9e10abe093deec0719fd7"></a><!-- doxytag: member="Gio::Socket::shutdown" ref="a4f685bc040e9e10abe093deec0719fd7" args="(bool shutdown_read, bool shutdown_write)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::shutdown </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>shutdown_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>shutdown_write</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shut down part of a full-duplex connection. </p>
<p>If <em>shutdown_read</em> is <code>true</code> then the recieving side of the connection is shut down, and further reading is disallowed.</p>
<p>If <em>shutdown_write</em> is <code>true</code> then the sending side of the connection is shut down, and further writing is disallowed.</p>
<p>It is allowed for both <em>shutdown_read</em> and <em>shutdown_write</em> to be <code>true</code>.</p>
<p>One example where this is used is graceful disconnect for TCP connections where you close the sending side, then wait for the other side to close the connection, thus ensuring that the other side saw all sent data.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000092">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shutdown_read</em>&#160;</td><td>Whether to shut down the read side. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shutdown_write</em>&#160;</td><td>Whether to shut down the write side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae33e646694bf6c5062683ba4b79d4fe1"></a><!-- doxytag: member="Gio::Socket::speaks_ipv4" ref="ae33e646694bf6c5062683ba4b79d4fe1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::speaks_ipv4 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a socket is capable of speaking IPv4. </p>
<p>IPv4 sockets are capable of speaking IPv4. On some operating systems and under some combinations of circumstances IPv6 sockets are also capable of speaking IPv4. See RFC 3493 section 3.7 for more information.</p>
<p>No other types of sockets are currently considered as being capable of speaking IPv4.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000108">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if this socket can be used with IPv4. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a4b4f2145105f84580f0a2659a9e8e5db"></a><!-- doxytag: member="Gio::Socket::wrap" ref="a4b4f2145105f84580f0a2659a9e8e5db" args="(GSocket *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Gio::Socket</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GSocket *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&#160;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&#160;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Mon May 3 23:46:29 2010 for glibmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
